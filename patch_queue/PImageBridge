# HG changeset patch
# Parent f57d24550c7d181609864ceafd1de70e58294d16

diff --git a/content/html/content/src/nsHTMLMediaElement.cpp b/content/html/content/src/nsHTMLMediaElement.cpp
--- a/content/html/content/src/nsHTMLMediaElement.cpp
+++ b/content/html/content/src/nsHTMLMediaElement.cpp
@@ -1,16 +1,19 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Util.h"
 
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "mozilla/layers/ImageContainerChild.h"
+#include "nsBaseWidget.h"
 #include "nsIDOMHTMLMediaElement.h"
 #include "nsIDOMHTMLSourceElement.h"
 #include "nsHTMLMediaElement.h"
 #include "nsTimeRanges.h"
 #include "nsGenericHTMLElement.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
 #include "nsGkAtoms.h"
@@ -2987,16 +2990,23 @@ VideoFrameContainer* nsHTMLMediaElement:
 
   // Only video frames need an image container.
   nsCOMPtr<nsIDOMHTMLVideoElement> video = do_QueryObject(this);
   if (!video)
     return nsnull;
 
   mVideoFrameContainer =
     new VideoFrameContainer(this, LayerManager::CreateImageContainer());
+  
+  if (mozilla::layers::ImageBridgeChild::IsCreated()) {
+    ImageContainerChild* child = 
+      mozilla::layers::ImageBridgeChild::GetSingleton()->CreateImageContainerChild();
+    mVideoFrameContainer->GetImageContainer()->SetImageContainerChild(child);
+  }
+
   return mVideoFrameContainer;
 }
 
 nsresult nsHTMLMediaElement::DispatchAudioAvailableEvent(float* aFrameBuffer,
                                                          PRUint32 aFrameBufferLength,
                                                          float aTime)
 {
   // Auto manage the memory for the frame buffer. If we fail and return
diff --git a/content/media/VideoFrameContainer.cpp b/content/media/VideoFrameContainer.cpp
--- a/content/media/VideoFrameContainer.cpp
+++ b/content/media/VideoFrameContainer.cpp
@@ -27,16 +27,17 @@ void VideoFrameContainer::SetCurrentFram
   }
 
   gfxIntSize oldFrameSize = mImageContainer->GetCurrentSize();
   TimeStamp lastPaintTime = mImageContainer->GetPaintTime();
   if (!lastPaintTime.IsNull() && !mPaintTarget.IsNull()) {
     mPaintDelay = lastPaintTime - mPaintTarget;
   }
   mImageContainer->SetCurrentImage(aImage);
+  mImageContainer->SetCurrentImageAsync(aImage);
   gfxIntSize newFrameSize = mImageContainer->GetCurrentSize();
   if (oldFrameSize != newFrameSize) {
     mImageSizeChanged = true;
   }
 
   mPaintTarget = aTargetTime;
 }
 
diff --git a/gfx/layers/ImageLayers.cpp b/gfx/layers/ImageLayers.cpp
--- a/gfx/layers/ImageLayers.cpp
+++ b/gfx/layers/ImageLayers.cpp
@@ -2,17 +2,19 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/ipc/Shmem.h"
 #include "mozilla/ipc/CrossProcessMutex.h"
 #include "ImageLayers.h"
 #include "gfxImageSurface.h"
+#include "gfxSharedImageSurface.h"
 #include "yuv_convert.h"
+#include "mozilla/layers/ImageContainerChild.h"
 
 #ifdef XP_MACOSX
 #include "nsCoreAnimationSupport.h"
 #endif
 
 #ifdef XP_WIN
 #include "gfxD2DSurface.h"
 #include "gfxWindowsPlatform.h"
@@ -76,17 +78,20 @@ BufferRecycleBin::GetBuffer(PRUint32 aSi
   PRUint32 last = mRecycledBuffers.Length() - 1;
   PRUint8* result = mRecycledBuffers[last].forget();
   mRecycledBuffers.RemoveElementAt(last);
   return result;
 }
 
 ImageContainer::~ImageContainer()
 {
-}
+  if (mImageContainerChild) {
+    mImageContainerChild->Destroy(); 
+  }
+ }
 
 already_AddRefed<Image>
 ImageContainer::CreateImage(const Image::Format *aFormats,
                             PRUint32 aNumFormats)
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
   return mImageFactory->CreateImage(aFormats, aNumFormats, mScaleHint, mRecycleBin);
 }
@@ -107,16 +112,27 @@ ImageContainer::SetCurrentImage(Image *a
   CurrentImageChanged();
 
   if (mRemoteData) {
     mRemoteDataMutex->Unlock();
   }
 }
 
 bool
+ImageContainer::SetCurrentImageAsync(Image * aImage)
+{
+  if (!mImageContainerChild) return false;
+  // TODO do we need to actually keep a ref to the image ?
+  // inthis case maybe we need a lock here also (if we do need to keep a reference)
+  mActiveImage = aImage;
+  mImageContainerChild->SendImageAsync(this, aImage);
+  return true;
+}
+
+bool
 ImageContainer::HasCurrentImage()
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
   if (mRemoteData) {
     CrossProcessMutexAutoLock autoLock(*mRemoteDataMutex);
     
     EnsureActiveImage();
diff --git a/gfx/layers/ImageLayers.h b/gfx/layers/ImageLayers.h
--- a/gfx/layers/ImageLayers.h
+++ b/gfx/layers/ImageLayers.h
@@ -32,16 +32,18 @@ namespace mozilla {
 
 class CrossProcessMutex;
 namespace ipc {
 class Shmem;
 }
 
 namespace layers {
 
+class ImageContainerChild;
+
 enum StereoMode {
   STEREO_MODE_MONO,
   STEREO_MODE_LEFT_RIGHT,
   STEREO_MODE_RIGHT_LEFT,
   STEREO_MODE_BOTTOM_TOP,
   STEREO_MODE_TOP_BOTTOM
 };
 
@@ -290,17 +292,18 @@ public:
   ImageContainer() :
     mReentrantMonitor("ImageContainer.mReentrantMonitor"),
     mPaintCount(0),
     mPreviousImagePainted(false),
     mImageFactory(new ImageFactory()),
     mRecycleBin(new BufferRecycleBin()),
     mRemoteData(nsnull),
     mRemoteDataMutex(nsnull),
-    mCompositionNotifySink(nsnull)
+    mCompositionNotifySink(nsnull),
+    mImageContainerChild(nsnull)
   {}
 
   ~ImageContainer();
 
   /**
    * Create an Image in one of the given formats.
    * Picks the "best" format from the list and creates an Image of that
    * format.
@@ -321,16 +324,26 @@ public:
    * The Image data must not be modified after this method is called!
    *
    * Implementations must call CurrentImageChanged() while holding
    * mReentrantMonitor.
    */
   void SetCurrentImage(Image* aImage);
 
   /**
+   * Schelude a task to set an image as the current Image to display
+   * using the PImageBridge protcol.
+   *
+   * The Image data must not be modified after this method is called!
+   *
+   * Can be called from any thread.
+   */
+  bool SetCurrentImageAsync(Image* aImage);
+
+  /**
    * Returns if the container currently has an image.
    * Can be called on any thread. This method takes mReentrantMonitor
    * when accessing thread-shared state.
    */
   bool HasCurrentImage();
 
   /**
    * Lock the current Image.
@@ -468,16 +481,27 @@ public:
    */
   void SetRemoteImageData(RemoteImageData *aRemoteData,
                           CrossProcessMutex *aRemoteDataMutex);
   /**
    * This can be used to check if the container has RemoteData set.
    */
   RemoteImageData *GetRemoteImageData() { return mRemoteData; }
 
+  // -------------- Async Image transfer
+
+  ImageContainerChild * GetImageContainerChild() const
+  {
+    return mImageContainerChild;
+  }
+  void SetImageContainerChild(ImageContainerChild * aChild)
+  {
+    mImageContainerChild = aChild;
+  }
+
 protected:
   typedef mozilla::ReentrantMonitor ReentrantMonitor;
 
   // This is called to ensure we have an active image, this may not be true
   // when we're storing image information in a RemoteImageData structure.
   // NOTE: If we have remote data mRemoteDataMutex should be locked when
   // calling this function!
   void EnsureActiveImage();
@@ -524,16 +548,19 @@ protected:
   RemoteImageData *mRemoteData;
 
   // This cross-process mutex is used to synchronise access to mRemoteData.
   // When this mutex is held, we will always be inside the mReentrantMonitor
   // however the same is not true vice versa.
   CrossProcessMutex *mRemoteDataMutex;
 
   CompositionNotifySink *mCompositionNotifySink;
+
+  // ImageBridgeProtocol
+  ImageContainerChild * mImageContainerChild;
 };
  
 class AutoLockImage
 {
 public:
   AutoLockImage(ImageContainer *aContainer) : mContainer(aContainer) { mImage = mContainer->LockCurrentImage(); }
   AutoLockImage(ImageContainer *aContainer, gfxASurface **aSurface) : mContainer(aContainer) {
     *aSurface = mContainer->LockCurrentAsSurface(&mSize, getter_AddRefs(mImage)).get();
diff --git a/gfx/layers/Makefile.in b/gfx/layers/Makefile.in
--- a/gfx/layers/Makefile.in
+++ b/gfx/layers/Makefile.in
@@ -105,27 +105,36 @@ EXPORTS_mozilla/layers =\
         CompositorCocoaWidgetHelper.h \
         CompositorChild.h \
         CompositorParent.h \
         ShadowLayers.h \
         ShadowLayersChild.h \
         ShadowLayersParent.h \
         ShadowLayersManager.h \
         RenderTrace.h \
+        ImageBridgeChild.h \
+        ImageBridgeParent.h \
+        ImageContainerChild.h \
+        ImageContainerParent.h \
+        SharedImageUtils.h \
         $(NULL)
 
 CPPSRCS += \
         CompositorCocoaWidgetHelper.cpp \
         CompositorChild.cpp \
         CompositorParent.cpp \
         ShadowLayers.cpp \
         ShadowLayerChild.cpp \
         ShadowLayersChild.cpp \
         ShadowLayerParent.cpp \
         ShadowLayersParent.cpp \
+        ImageBridgeChild.cpp \
+        ImageBridgeParent.cpp \
+        ImageContainerChild.cpp \
+        ImageContainerParent.cpp \
         $(NULL)
 
 ifdef MOZ_X11 #{
 EXPORTS_mozilla/layers += ShadowLayerUtilsX11.h
 CPPSRCS += ShadowLayerUtilsX11.cpp
 endif #}
 
 ifdef MOZ_ENABLE_D3D10_LAYER
diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp
--- a/gfx/layers/basic/BasicLayers.cpp
+++ b/gfx/layers/basic/BasicLayers.cpp
@@ -2,16 +2,17 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Attributes.h"
 
 #include "gfxSharedImageSurface.h"
 
+#include "mozilla/layers/ImageContainerChild.h"
 #include "mozilla/layers/PLayerChild.h"
 #include "mozilla/layers/PLayersChild.h"
 #include "mozilla/layers/PLayersParent.h"
 #include "mozilla/gfx/2D.h"
 
 #include "ipc/ShadowLayerChild.h"
 
 #include "BasicLayers.h"
@@ -2616,16 +2617,23 @@ BasicShadowableImageLayer::Paint(gfxCont
     BasicImageLayer::Paint(aContext, aMaskLayer);
     return;
   }
 
   if (!mContainer) {
     return;
   }
 
+  if (mContainer->GetImageContainerChild()) {
+    PRUint64 imageID = mContainer->GetImageContainerChild()->GetImageID();
+    SharedImage* refImg = new SharedImage(*new SharedImageID(imageID));
+    BasicManager()->PaintedImage(BasicManager()->Hold(this), *refImg);
+    return;
+  }
+
   AutoLockImage autoLock(mContainer);
 
   Image *image = autoLock.GetImage();
 
   if (!image) {
     return;
   }
 
diff --git a/gfx/layers/ipc/CompositorParent.h b/gfx/layers/ipc/CompositorParent.h
--- a/gfx/layers/ipc/CompositorParent.h
+++ b/gfx/layers/ipc/CompositorParent.h
@@ -23,17 +23,17 @@
 
 class nsIWidget;
 
 namespace mozilla {
 namespace layers {
 
 class LayerManager;
 
-// Represents (affine) transforms that are calculated from a content view.
+// Represents (affine) transforms thapt are calculated from a content view.
 struct ViewTransform {
   ViewTransform(nsIntPoint aTranslation = nsIntPoint(0, 0), float aXScale = 1, float aYScale = 1)
     : mTranslation(aTranslation)
     , mXScale(aXScale)
     , mYScale(aYScale)
   {}
 
   operator gfx3DMatrix() const
@@ -72,36 +72,38 @@ public:
   void SetTransformation(float aScale, nsIntPoint aScrollOffset);
   void AsyncRender();
 
   // Can be called from any thread
   void ScheduleRenderOnCompositorThread();
   void SchedulePauseOnCompositorThread();
   void ScheduleResumeOnCompositorThread(int width, int height);
 
+  virtual void ScheduleComposition();
+  
+  inline MessageLoop* CompositorLoop();
+  
 protected:
   virtual PLayersParent* AllocPLayers(const LayersBackend& aBackendType, int* aMaxTextureSize);
   virtual bool DeallocPLayers(PLayersParent* aLayers);
   virtual void ScheduleTask(CancelableTask*, int);
   virtual void Composite();
-  virtual void ScheduleComposition();
   virtual void SetFirstPaintViewport(const nsIntPoint& aOffset, float aZoom, const nsIntRect& aPageRect, const gfx::Rect& aCssPageRect);
   virtual void SetPageRect(float aZoom, const nsIntRect& aPageRect, const gfx::Rect& aCssPageRect);
   virtual void SyncViewportInfo(const nsIntRect& aDisplayPort, float aDisplayResolution, bool aLayersUpdated,
                                 nsIntPoint& aScrollOffset, float& aScaleX, float& aScaleY);
   void SetEGLSurfaceSize(int width, int height);
 
 private:
   void PauseComposition();
   void ResumeComposition();
   void ResumeCompositionAndResize(int width, int height);
 
   void TransformShadowTree();
 
-  inline MessageLoop* CompositorLoop();
   inline PlatformThreadId CompositorThreadID();
 
   // Platform specific functions
   /**
    * Does a breadth-first search to find the first layer in the tree with a
    * displayport set.
    */
   Layer* GetPrimaryScrollableLayer();
diff --git a/gfx/layers/ipc/ImageBridgeChild.cpp b/gfx/layers/ipc/ImageBridgeChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.cpp
@@ -0,0 +1,175 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageBridgeChild.h"
+#include "ImageContainerChild.h"
+#include "ImageBridgeParent.h"
+#include "gfxSharedImageSurface.h"
+#include "ImageLayers.h"
+#include "base/thread.h"
+#include "mozilla/ReentrantMonitor.h"
+
+namespace mozilla {
+namespace layers {
+
+namespace {
+  ImageBridgeChild* sImageBridgeChildSingleton = nsnull;
+}
+
+bool ImageBridgeChild::Create(base::Thread* aThread)
+{
+  if (sImageBridgeChildSingleton == nsnull) {
+    sImageBridgeChildSingleton = new ImageBridgeChild(aThread);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+ImageBridgeChild* ImageBridgeChild::GetSingleton()
+{
+  return sImageBridgeChildSingleton;
+}
+
+bool ImageBridgeChild::IsCreated()
+{
+  return GetSingleton() != nsnull;
+}
+
+ImageBridgeChild::ImageBridgeChild(base::Thread* aThread)
+{
+  mThread = aThread;
+  if (!mThread->IsRunning()) {
+    mThread->Start();
+  }
+}
+
+ImageBridgeChild::~ImageBridgeChild()
+{
+}
+
+
+// IPDL protocol
+
+
+PImageContainerChild* ImageBridgeChild::AllocPImageContainer(PRUint64* id)
+{
+  NS_ABORT();
+  return nsnull;
+}
+
+bool ImageBridgeChild::DeallocPImageContainer(PImageContainerChild* aImgContainerChild)
+{
+  delete aImgContainerChild;
+  return true;
+}
+
+
+
+bool ImageBridgeChild::InImageBridgeChildThread() const {
+  return mThread->thread_id() == PlatformThread::CurrentId();
+}
+
+
+
+MessageLoop * ImageBridgeChild::GetMessageLoop() const
+{
+  return mThread->message_loop();
+}
+
+
+// async opertations:
+
+class ImageBridgeConnectionTask : public Task
+{
+public:
+  ImageBridgeConnectionTask(ImageBridgeChild * child, ImageBridgeParent * parent)
+  : mChild(child), mParent(parent) {}
+
+  void Run()
+  {
+    mChild->ConnectNow(mParent);
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageBridgeParent * mParent;
+};
+
+class ImageBridgeCreateContainerChildTask : public Task
+{
+public:
+  ImageBridgeCreateContainerChildTask(ImageBridgeChild * child, 
+                                      ImageContainerChild** result, 
+                                      ReentrantMonitor* barrier)
+  : mChild(child), mResult(result), mSync(barrier) {}
+
+  void Run()
+  {
+    ReentrantMonitorAutoEnter autoMon(*mSync);
+    *mResult = mChild->CreateImageContainerChildNow();
+    mSync->NotifyAll();
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageContainerChild** mResult;
+  ReentrantMonitor* mSync;
+};
+
+void ImageBridgeChild::ConnectNow(ImageBridgeParent* aParent)
+{
+    MessageLoop * parentMsgLoop = aParent->GetMessageLoop();
+    ipc::AsyncChannel * parentChannel = aParent->GetIPCChannel();
+    this->Open(parentChannel, parentMsgLoop, mozilla::ipc::AsyncChannel::Child);
+}
+
+void ImageBridgeChild::ConnectAsync(ImageBridgeParent* aParent)
+{
+  Task * t = new ImageBridgeConnectionTask(this, aParent);
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+}
+
+ImageContainerChild* ImageBridgeChild::CreateImageContainerChild()
+{
+  if (InImageBridgeChildThread()) {
+    return ImageBridgeChild::CreateImageContainerChildNow(); 
+  } 
+ 
+  // ImageContainerChild can only be alocated on the ImageBridgeChild thread, so se
+  // dispatch a task to the thread and block the current thread until the task has been
+  // executed.
+  ImageContainerChild* result = nsnull;
+  
+  ReentrantMonitor barrier("CreateImageContainerChild Lock");
+  ReentrantMonitorAutoEnter autoMon(barrier);
+
+  Task * t = new ImageBridgeCreateContainerChildTask(this, &result, &barrier);
+  
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+  
+  // should stop the thread until the ImageContainerChild has been created on 
+  // the other thread
+  barrier.Wait();
+  return result;
+}
+
+namespace {
+  // TODO: make this thread safe and unique accross processes
+  PRUint64 GenUniqueID() {
+    static PRUint64 sNextID = 1;
+    return ++sNextID;
+  }
+}
+
+ImageContainerChild* ImageBridgeChild::CreateImageContainerChildNow()
+{
+  ImageContainerChild* ctnChild = new ImageContainerChild(this);
+  PRUint64 id = 0; 
+  SendPImageContainerConstructor(ctnChild, &id);
+  ctnChild->SetImageID(id);
+  return ctnChild;
+}
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeChild.h b/gfx/layers/ipc/ImageBridgeChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.h
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGEBRIDGECHILD_H
+#define MOZILLA_GFX_IMAGEBRIDGECHILD_H
+
+#include "mozilla/layers/PImageBridgeChild.h"
+
+class gfxSharedImageSurface;
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class ImageContainerChild;
+class ImageBridgeParent;
+class ImageBridgeConnectionTask;
+class ImageBridgeCreateContainerChildTask;
+class SharedImage;
+class Image;
+
+class ImageBridgeChild : public PImageBridgeChild
+{
+// NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VideoBridgeChild)
+friend class mozilla::layers::ImageBridgeConnectionTask;
+friend class mozilla::layers::ImageBridgeCreateContainerChildTask;
+
+public:
+
+  ImageBridgeChild(base::Thread* aThread);
+  ~ImageBridgeChild();
+
+  static bool Create(base::Thread* aThread);
+  static void Destroy();
+  static bool IsCreated();
+  static ImageBridgeChild* GetSingleton();
+
+  // IPDL protocol
+
+  // Temporary, not suitable for cross-process layers
+  // can be called from any thread
+  void ConnectAsync(ImageBridgeParent* aParent);
+    
+  /**
+   * Returns the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  base::Thread * GetThread() const
+  {
+    return mThread;
+  }
+
+  MessageLoop * GetMessageLoop() const;
+
+  /**
+   * Returns true if the current thread is the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  bool InImageBridgeChildThread() const;
+
+  ImageContainerChild* CreateImageContainerChild();
+
+  PImageContainerChild* AllocPImageContainer(PRUint64*);
+  bool DeallocPImageContainer(PImageContainerChild* aImgContainerChild);
+
+protected:
+
+  /** 
+   * must be called in the ImageBridgeChild thread.
+   */
+  void ConnectNow(ImageBridgeParent* aParent);
+  ImageContainerChild* CreateImageContainerChildNow();
+
+  /**
+   * Dispatch a task in the ImageBridgeChild thread to send an 
+   * image through IPC to the compositor.
+   *
+   * Can be called from any thread.
+   */
+
+private:
+  base::Thread * mThread;
+};
+
+} // layers
+} // mozilla
+
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.cpp b/gfx/layers/ipc/ImageBridgeParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.cpp
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/ImageBridgeParent.h"
+#include "mozilla/layers/ImageContainerParent.h"
+#include "mozilla/layers/CompositorParent.h"
+
+#include "base/thread.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace layers {
+
+
+ImageBridgeParent::ImageBridgeParent(CompositorParent* aCompositor)
+: mCompositorParent(aCompositor)
+{
+
+}
+
+ImageBridgeParent::~ImageBridgeParent()
+{
+}
+
+namespace {
+  PRUint64 GenImageID() {
+    static PRUint64 sNextImageID = 1;
+    ++sNextImageID;
+    while ((sNextImageID == 0) || 
+           ImageContainerParent::IsExistingID(sNextImageID)) {
+      ++sNextImageID;
+    }
+    return sNextImageID;
+  }
+}
+  
+PImageContainerParent* ImageBridgeParent::AllocPImageContainer(PRUint64* aID)
+{
+  PRUint64 id = GenImageID();
+  *aID = id;
+  return new ImageContainerParent(this, id);
+}
+
+bool ImageBridgeParent::DeallocPImageContainer(PImageContainerParent* toDealloc)
+{
+  delete toDealloc;
+  return true;
+}
+
+
+void ImageBridgeParent::ScheduleComposition()
+{
+  mCompositorParent->ScheduleComposition();
+}
+
+// IPDL protocol
+
+MessageLoop * ImageBridgeParent::GetMessageLoop() {
+  return mCompositorParent->CompositorLoop();
+}
+
+
+bool ImageBridgeParent::RecvWillStop()
+{
+  // TODO
+  return false;
+}
+
+
+
+
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.h b/gfx/layers/ipc/ImageBridgeParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/PImageBridgeParent.h"
+#include "ShadowLayers.h"
+
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class CompositorParent;
+
+class ImageBridgeParent : public PImageBridgeParent
+{
+public:
+
+  ImageBridgeParent(CompositorParent* aCompositor);
+  ~ImageBridgeParent();
+
+  void ScheduleComposition();
+
+  bool RecvWillStop();
+
+  PImageContainerParent* AllocPImageContainer(PRUint64* aID);
+  bool DeallocPImageContainer(PImageContainerParent* toDealloc);
+
+  MessageLoop * GetMessageLoop();
+
+private:
+  CompositorParent * mCompositorParent;
+};
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerChild.cpp b/gfx/layers/ipc/ImageContainerChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerChild.cpp
@@ -0,0 +1,186 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#include "ImageContainerChild.h"
+#include "gfxPlatform.h"
+#include "gfxSharedImageSurface.h"
+#include "ShadowLayers.h"
+#include "mozilla/layers/PLayers.h"
+#include "mozilla/ReentrantMonitor.h"
+#include "mozilla/layers/SharedImageUtils.h"
+
+namespace mozilla {
+namespace layers {
+
+// TODO debug
+static int _debug_sharedAllocCount = 0;
+
+ImageContainerChild::~ImageContainerChild()
+{
+}
+
+bool ImageContainerChild::RecvReleasedSharedImage(const SharedImage& aImage)
+{
+  // TODO: pool them instead
+  DestroySharedImage(aImage);
+  return true;
+}
+
+bool ImageContainerChild::AllocBuffer(const gfxIntSize& aSize,
+                                   gfxASurface::gfxContentType aContent,
+                                   gfxSharedImageSurface** aBuffer)
+{
+  SharedMemory::SharedMemoryType shmemType = ipc::OptimalShmemType();
+  gfxASurface::gfxImageFormat format = gfxPlatform::GetPlatform()->OptimalFormatForContent(aContent);
+
+  nsRefPtr<gfxSharedImageSurface> back =
+    gfxSharedImageSurface::CreateUnsafe(this, aSize, format, shmemType);
+  if (!back)
+    return false;
+
+  *aBuffer = nsnull;
+  back.swap(*aBuffer);
+  return true;
+}
+
+void ImageContainerChild::DestroySharedImage(const SharedImage& aImage)
+{
+  _debug_sharedAllocCount--;
+  
+  DeallocSharedImageData(this, aImage);
+}
+
+SharedImage* ImageContainerChild::CopyImageIntoSharedImage(Image* image)
+{
+  _debug_sharedAllocCount++;
+  /* how to access buffer directly into a SharedImage:
+    unsigned char * yBufferData = dest->get_MediSharedImage().Ydata().get<unsigned char>();
+    unsigned char * uBufferData = dest->get_MediSharedImage().Udata().get<unsigned char>();
+    unsigned char * vBufferData = dest->get_MediSharedImage().Vdata().get<unsigned char>();
+  */
+  // TODO: I don't test for BasicManager()->IsCompositingCheap() here,
+  // is this a problem?
+  if (image->GetFormat() == Image::PLANAR_YCBCR ) {
+    PlanarYCbCrImage *YCbCrImage = static_cast<PlanarYCbCrImage*>(image);
+    const PlanarYCbCrImage::Data *data = YCbCrImage->GetData();
+    NS_ASSERTION(data, "Must be able to retrieve yuv data from image!");
+    
+    nsRefPtr<gfxSharedImageSurface> tempBufferY;
+    nsRefPtr<gfxSharedImageSurface> tempBufferU;
+    nsRefPtr<gfxSharedImageSurface> tempBufferV;
+    
+    if (!this->AllocBuffer(data->mYSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferY)) ||
+        !this->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferU)) ||
+        !this->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferV))) {
+      NS_RUNTIMEABORT("creating SharedImage failed!");
+    }
+
+    for (int i = 0; i < data->mYSize.height; i++) {
+      memcpy(tempBufferY->Data() + i * tempBufferY->Stride(),
+             data->mYChannel + i * data->mYStride,
+             data->mYSize.width);
+    }
+    for (int i = 0; i < data->mCbCrSize.height; i++) {
+      memcpy(tempBufferU->Data() + i * tempBufferU->Stride(),
+             data->mCbChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+      memcpy(tempBufferV->Data() + i * tempBufferV->Stride(),
+             data->mCrChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+    }
+
+    SharedImage* result = new SharedImage( 
+              *(new YUVImage(tempBufferY->GetShmem(),
+                                             tempBufferU->GetShmem(),
+                                             tempBufferV->GetShmem(),
+                                             data->GetPictureRect())));
+    NS_ABORT_IF_FALSE(result->type() == SharedImage::TYUVImage,
+                      "SharedImage type not set correctly");
+    return result;
+  } else {
+    NS_RUNTIMEABORT("TODO: Only YUVImage is supported here right now.");
+  }
+  return nsnull;
+}
+
+
+
+// TODO! handle refPtr correctly
+class ImageBridgeCopyAndSendTask : public Task
+{
+public:
+  ImageBridgeCopyAndSendTask(ImageContainerChild * child, 
+                             ImageContainer * aContainer, 
+                             Image * aImage)
+  : mChild(child), mImageContainer(aContainer), mImage(aImage) {}
+
+  void Run()
+  {
+    SharedImage* img = 
+        mChild->CopyImageIntoSharedImage(mImage);
+
+    mChild->SendPushSharedImage(*img);
+  }
+private:
+  ImageContainerChild * mChild;
+  nsRefPtr<ImageContainer> mImageContainer;
+  nsRefPtr<Image> mImage;
+};
+
+void ImageContainerChild::SendImageAsync(ImageContainer* aContainer,
+                                         Image* aImage)
+{
+  if (InImageBridgeChildThread()) {
+    SharedImage* img = CopyImageIntoSharedImage(aImage);
+    SendPushSharedImage(*img);
+    return;
+  }
+
+  // Sending images and (potentially) allocating shmems must be done 
+  // on the ImageBrdgeChild thread.
+  Task * t = new ImageBridgeCopyAndSendTask(this, aContainer, aImage);   
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+}
+
+
+
+class ImageContainerChildDestroyTask : public Task
+{
+public:
+  ImageContainerChildDestroyTask(ImageContainerChild* aChild)
+  : mImageContainerChild(aChild) {}
+  void Run() 
+  {
+    mImageContainerChild->DestroyNow();
+  }
+private:
+  ImageContainerChild* mImageContainerChild;
+};
+
+void ImageContainerChild::DestroyNow()
+{
+  // TODO: destroy shmems in the pool
+
+  Send__delete__(this);
+}
+
+void ImageContainerChild::Destroy()
+{
+  if (InImageBridgeChildThread()) {
+    DestroyNow();
+    return;
+  }
+
+  // destruction must be done on the ImageBridgeChild thread
+  Task * t = new ImageContainerChildDestroyTask(this);   
+  GetMessageLoop()->PostTask(FROM_HERE, t);  
+}
+
+} // namespace
+} // namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerChild.h b/gfx/layers/ipc/ImageContainerChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerChild.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGECONTAINERCHILD_H
+#define MOZILLA_GFX_IMAGECONTAINERCHILD_H
+
+#include "mozilla/layers/PImageContainerChild.h"
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "ImageLayers.h"
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeCopyAndSendTask;
+
+class ImageContainerChild : public PImageContainerChild
+{
+  friend class ImageBridgeChild;
+  friend class ImageContainerChildDestroyTask;
+  friend class ImageBridgeCopyAndSendTask;
+
+public:
+  ImageContainerChild(ImageBridgeChild* aBridge)
+  : mBridge(aBridge), mImageID(0) {}
+
+  virtual ~ImageContainerChild();
+
+  void SendImageAsync(ImageContainer* aContainer, Image* aImage);
+
+  SharedImage * CopyImageIntoSharedImage(Image* aImage);
+
+  inline ImageBridgeChild* GetImageBridgeChild() const {
+    return mBridge; 
+  }
+
+  inline MessageLoop* GetMessageLoop() const {
+    return mBridge->GetMessageLoop();
+  }
+
+  inline bool InImageBridgeChildThread() const {
+    return mBridge->InImageBridgeChildThread();
+  }
+
+  const PRUint64& GetImageID() const
+  {
+    return mImageID;
+  }
+
+  bool RecvReleasedSharedImage(const SharedImage& aImage);
+
+  /**
+   * Dispatches a task to the ImageBridge Thread.
+   */
+  void Destroy();
+
+protected:
+
+
+  void DestroyNow();
+
+  inline void SetImageID(PRUint64 id)
+  {
+    mImageID = id;
+  }
+
+  /**
+   * Same as ShadowLayerForwarder::AllocBuffer.
+   *
+   * TODO: better doc :)
+   */
+  bool AllocBuffer(const gfxIntSize& aSize,
+                   gfxASurface::gfxContentType aContent,
+                   gfxSharedImageSurface** aBuffer);
+
+  bool AllocSharedImage(const gfxIntSize& aSize,
+                        gfxASurface::gfxContentType aContent,
+                        SharedImage& aImage);
+
+  void DestroySharedImage(const SharedImage& aSurface);
+
+private:
+
+  ImageBridgeChild* mBridge;
+  PRUint64 mImageID;
+  // shared image pool here 
+};
+
+
+} // namespace
+} // namespace
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerParent.cpp b/gfx/layers/ipc/ImageContainerParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerParent.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/ImageContainerParent.h"
+#include "mozilla/layers/ImageBridgeParent.h"
+#include "mozilla/layers/SharedImageUtils.h"
+#include "CompositorParent.h" // for SharedImage, will be removed
+
+namespace mozilla {
+namespace layers {
+
+bool ImageContainerParent::RecvPushSharedImage(const SharedImage& aImage)
+{
+  SharedImage * copy = new SharedImage(aImage);
+  SharedImage * prevImage = SwapSharedImage(mID, copy);
+
+  mBridge->ScheduleComposition();
+  if (prevImage) {
+    SendReleasedSharedImage(*prevImage);
+    delete prevImage;
+  }
+  return true;
+}
+
+bool ImageContainerParent::Recv__delete__()
+{
+  SharedImage* removed = RemoveSharedImage(mID);
+  if (removed) {
+    DeallocSharedImageData(this, *removed);
+    delete removed;
+  }
+
+  return true;
+}
+
+namespace {
+  // TODO: replace this naive map implementation with whatever  
+  // everyone agrees on (std::map?)
+  struct ImageIDPair {
+    ImageIDPair(SharedImage* aImage, PRUint64 aID)
+    : image(aImage), id(aID), version(1) {}
+    SharedImage*   image;
+    PRUint64            id;
+    PRUint32            version;
+  };
+
+  nsTArray<ImageIDPair> sSharedImageMap;
+
+  enum {_INVALID_INDEX=-1};
+
+  int IndexOf(PRUint64 aID)
+  {
+    for (int i = 0; i < sSharedImageMap.Length(); ++i) {
+      if (sSharedImageMap[i].id == aID) {
+        return i;
+      }
+    }
+    return _INVALID_INDEX;
+  }
+} // anonymous namespace
+
+bool ImageContainerParent::IsExistingID(PRUint64 aID)
+{
+  return IndexOf(aID) != _INVALID_INDEX;
+}
+
+SharedImage* ImageContainerParent::SwapSharedImage(PRUint64 aID, 
+                                                        SharedImage* aImage)
+{
+  int idx = IndexOf(aID);
+  if (idx == _INVALID_INDEX) {
+    sSharedImageMap.AppendElement(ImageIDPair(aImage,aID));
+  return nsnull;
+  }
+  SharedImage* test = GetSharedImage(aID);
+  SharedImage* prev = sSharedImageMap[idx].image;
+  sSharedImageMap[idx].image = aImage;
+  sSharedImageMap[idx].version++;
+  return prev;
+}
+
+PRUint32 ImageContainerParent::GetSharedImageVersion(PRUint64 aID)
+{
+  int idx = IndexOf(aID);
+  if (idx == _INVALID_INDEX) return 0;
+  return sSharedImageMap[idx].version;
+}
+
+SharedImage* ImageContainerParent::RemoveSharedImage(PRUint64 aID) 
+{
+  int idx = IndexOf(aID);
+  if (idx != _INVALID_INDEX) {
+    SharedImage* img = sSharedImageMap[idx].image;
+    sSharedImageMap.RemoveElementAt(idx);
+    return img;
+  }
+  return nsnull;
+}
+
+SharedImage* ImageContainerParent::GetSharedImage(PRUint64 aID)
+{
+  int idx = IndexOf(aID);
+  if (idx != _INVALID_INDEX) {
+    return sSharedImageMap[idx].image;
+  }
+  return nsnull;
+}
+
+
+} // namespace
+} // namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerParent.h b/gfx/layers/ipc/ImageContainerParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerParent.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGECONTAINERPARENT_H
+#define MOZILLA_GFX_IMAGECONTAINERPARENT_H
+
+#include "mozilla/layers/PImageContainerParent.h"
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeParent;
+
+class ImageContainerParent : public PImageContainerParent
+{
+public:
+
+  ImageContainerParent(ImageBridgeParent* aBridge, PRUint64 aHandle)
+  : mBridge(aBridge), mID(aHandle) {}
+
+  bool RecvPushSharedImage(const SharedImage& aImage);
+  bool Recv__delete__();
+
+  static SharedImage* GetSharedImage(PRUint64 aID);
+  /**
+   * Evere time a SharedImage is swaped, the a version counter associated with the 
+   * id is incremented. This allows ImageLayers to compare the current image with the
+   * one that has been displayed last (in particular on OGL backend we can avoid uploading
+   * the same texture twice if composition happens more frequently than ImageBridge 
+   * transfers);
+   */
+  static PRUint32 GetSharedImageVersion(PRUint64 aID);
+  static bool IsExistingID(PRUint64 aID);
+
+protected:
+  static SharedImage* SwapSharedImage(PRUint64 aID, SharedImage* aImage);
+  static SharedImage* RemoveSharedImage(PRUint64 aID);
+
+private:
+  ImageBridgeParent* mBridge;
+  PRUint64 mID;
+};
+
+
+} // namespace
+} // namespace
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/PImageBridge.ipdl b/gfx/layers/ipc/PImageBridge.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PImageBridge.ipdl
@@ -0,0 +1,30 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PImageContainer;
+
+using ImageHandle;
+
+namespace mozilla {
+namespace layers {
+
+/**
+ * The PImageBridge protocol is used to allow isolated threads or processes to push
+ * frames directly to the compositor thread/process without relying on the main thread
+ * which might be too busy dealing with content script.
+ */
+sync protocol PImageBridge
+{
+  manages PImageContainer;
+
+parent:
+  async WillStop();
+  
+  sync PImageContainer() returns (PRUint64 id);
+};
+
+
+} //namespace
+} //namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/PImageContainer.ipdl b/gfx/layers/ipc/PImageContainer.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PImageContainer.ipdl
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PImageBridge;
+include LayersSurfaces;
+
+namespace mozilla {
+namespace layers {
+
+
+/**
+ * The PImageBridge protocol is used to allow isolated threads or processes to push
+ * frames directly to the compositor thread/process without relying on the main thread
+ * which might be too busy dealing with content script.
+ */
+async protocol PImageContainer
+{
+  manager PImageBridge;
+
+child:
+  // Give back the child thread/process ownership to a SharedImage
+  ReleasedSharedImage(SharedImage image);
+
+parent:
+
+  // Send a SharedImage to the compositor giving to the compositor ownership 
+  // of the image.
+  PushSharedImage(SharedImage image);
+  __delete__();
+
+};
+
+
+} // namespace
+} // namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/PLayers.ipdl b/gfx/layers/ipc/PLayers.ipdl
--- a/gfx/layers/ipc/PLayers.ipdl
+++ b/gfx/layers/ipc/PLayers.ipdl
@@ -3,30 +3,18 @@
  */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PCompositor;
 include protocol PLayer;
 include protocol PRenderFrame;
+include LayersSurfaces;
 
-include "gfxipc/ShadowLayerUtils.h";
-
-using gfx3DMatrix;
-using gfxRGBA;
-using nsIntPoint;
-using nsIntRect;
-using nsIntRegion;
-using nsIntSize;
-using mozilla::GraphicsFilterType;
-using mozilla::layers::FrameMetrics;
-using mozilla::layers::SurfaceDescriptorX11;
-using mozilla::null_t;
-using mozilla::WindowsHandle;
 
 /**
  * The layers protocol is spoken between thread contexts that manage
  * layer (sub)trees.  The protocol comprises atomically publishing
  * layer subtrees to a "shadow" thread context (which grafts the
  * subtree into its own tree), and atomically updating a published
  * subtree.  ("Atomic" in this sense is wrt painting.)
  */
@@ -36,38 +24,17 @@ namespace layers {
 
 // Create a shadow layer for |layer|
 struct OpCreateThebesLayer     { PLayer layer; };
 struct OpCreateContainerLayer  { PLayer layer; };
 struct OpCreateImageLayer      { PLayer layer; };
 struct OpCreateColorLayer      { PLayer layer; };
 struct OpCreateCanvasLayer     { PLayer layer; };
 
-struct SurfaceDescriptorD3D10 {
-  WindowsHandle handle;
-};
 
-union SurfaceDescriptor {
-  Shmem;
-  SurfaceDescriptorD3D10;
-  SurfaceDescriptorX11;
-};
-
-struct YUVImage {
-  Shmem Ydata;
-  Shmem Udata;
-  Shmem Vdata;
-  nsIntRect picture;
-};
-
-union SharedImage {
-  SurfaceDescriptor;
-  YUVImage;
-  null_t;
-};
 
 struct ThebesBuffer {
   SurfaceDescriptor buffer;
   nsIntRect rect;
   nsIntPoint rotation; 
 };
 union OptionalThebesBuffer { ThebesBuffer; null_t; };
 
diff --git a/gfx/layers/ipc/ShadowLayers.cpp b/gfx/layers/ipc/ShadowLayers.cpp
--- a/gfx/layers/ipc/ShadowLayers.cpp
+++ b/gfx/layers/ipc/ShadowLayers.cpp
@@ -105,16 +105,17 @@ struct AutoTxnEnd {
   Transaction* mTxn;
 };
 
 ShadowLayerForwarder::ShadowLayerForwarder()
  : mShadowManager(NULL)
  , mMaxTextureSize(0)
  , mParentBackend(LayerManager::LAYERS_NONE)
  , mIsFirstPaint(false)
+ , mImageBridgeChild(NULL)
 {
   mTxn = new Transaction();
 }
 
 ShadowLayerForwarder::~ShadowLayerForwarder()
 {
   NS_ABORT_IF_FALSE(mTxn->Finished(), "unfinished transaction?");
   delete mTxn;
diff --git a/gfx/layers/ipc/ShadowLayers.h b/gfx/layers/ipc/ShadowLayers.h
--- a/gfx/layers/ipc/ShadowLayers.h
+++ b/gfx/layers/ipc/ShadowLayers.h
@@ -32,16 +32,18 @@ class ShadowColorLayer;
 class ShadowCanvasLayer;
 class SurfaceDescriptor;
 class ThebesBuffer;
 class TiledLayerComposer;
 class Transaction;
 class SharedImage;
 class CanvasSurface;
 class BasicTiledLayerBuffer;
+class ImageBridgeParent;
+class ImageBridgeChild;
 
 /**
  * We want to share layer trees across thread contexts and address
  * spaces for several reasons; chief among them
  *
  *  - a parent process can paint a child process's layer tree while
  *    the child process is blocked, say on content script.  This is
  *    important on mobile devices where UI responsiveness is key.
@@ -300,16 +302,19 @@ public:
   /**
    * Flag the next paint as the first for a document.
    */
   void SetIsFirstPaint() { mIsFirstPaint = true; }
 
   virtual PRInt32 GetMaxTextureSize() const { return mMaxTextureSize; }
   void SetMaxTextureSize(PRInt32 aMaxTextureSize) { mMaxTextureSize = aMaxTextureSize; }
 
+  void SetImageBridge(ImageBridgeChild* aBridge) { mImageBridgeChild = aBridge; }
+  ImageBridgeChild* GetImageBridge() const { return mImageBridgeChild; }
+
 protected:
   ShadowLayerForwarder();
 
   PLayersChild* mShadowManager;
 
 private:
   bool PlatformAllocDoubleBuffer(const gfxIntSize& aSize,
                                    gfxASurface::gfxContentType aContent,
@@ -327,16 +332,17 @@ private:
 
   static void PlatformSyncBeforeUpdate();
 
   Transaction* mTxn;
   PRInt32 mMaxTextureSize;
   LayersBackend mParentBackend;
 
   bool mIsFirstPaint;
+  ImageBridgeChild * mImageBridgeChild;
 };
 
 
 class ShadowLayerManager : public LayerManager
 {
 public:
   virtual ~ShadowLayerManager() {}
 
@@ -583,18 +589,24 @@ public:
                     SharedImage* aNewBack) = 0;
 
   virtual ShadowLayer* AsShadowLayer() { return this; }
 
   MOZ_LAYER_DECL_NAME("ShadowImageLayer", TYPE_SHADOW)
 
 protected:
   ShadowImageLayer(LayerManager* aManager, void* aImplData)
-    : ImageLayer(aManager, aImplData)
+    : ImageLayer(aManager, aImplData), 
+      mImageID(0),
+      mImageVersion(0)
   {}
+
+  // ImageBridge protocol:
+  PRUint64 mImageID;
+  PRUint32 mImageVersion;
 };
 
 
 class ShadowColorLayer : public ShadowLayer,
                          public ColorLayer
 {
 public:
   virtual ShadowLayer* AsShadowLayer() { return this; }
diff --git a/gfx/layers/ipc/SharedImageUtils.h b/gfx/layers/ipc/SharedImageUtils.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/SharedImageUtils.h
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_LAYERS_SHAREDIMAGEUTILS_H
+#define MOZILLA_LAYERS_SHAREDIMAGEUTILS_H
+
+#include "mozilla/layers/ImageContainerChild.h"
+
+namespace mozilla {
+namespace layers {
+
+template<typename Deallocator>
+void DeallocSharedImageData(Deallocator* protocol, const SharedImage& aImage)
+{
+  if (aImage.type() == SharedImage::TYUVImage) {
+    protocol->DeallocShmem(aImage.get_YUVImage().Ydata());
+    protocol->DeallocShmem(aImage.get_YUVImage().Udata());
+    protocol->DeallocShmem(aImage.get_YUVImage().Vdata());
+  } else if (aImage.type() == SharedImage::TSurfaceDescriptor) {
+    protocol->DeallocShmem(aImage.get_SurfaceDescriptor().get_Shmem());
+  }
+}
+
+} // namespace
+} // namespace
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/ipdl.mk b/gfx/layers/ipc/ipdl.mk
--- a/gfx/layers/ipc/ipdl.mk
+++ b/gfx/layers/ipc/ipdl.mk
@@ -1,9 +1,12 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 IPDLSRCS = \
   PCompositor.ipdl \
   PLayer.ipdl \
   PLayers.ipdl \
+  PImageBridge.ipdl \
+  PImageContainer.ipdl \
+  LayersSurfaces.ipdlh \
   $(NULL)
diff --git a/gfx/layers/opengl/ImageLayerOGL.cpp b/gfx/layers/opengl/ImageLayerOGL.cpp
--- a/gfx/layers/opengl/ImageLayerOGL.cpp
+++ b/gfx/layers/opengl/ImageLayerOGL.cpp
@@ -1,15 +1,15 @@
 /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "gfxSharedImageSurface.h"
-
+#include "mozilla/layers/ImageContainerParent.h"
 #include "ImageLayerOGL.h"
 #include "gfxImageSurface.h"
 #include "gfxUtils.h"
 #include "yuv_convert.h"
 #include "GLContextProvider.h"
 #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 # include "GLXLibrary.h"
 # include "mozilla/X11Util.h"
@@ -696,19 +696,24 @@ ShadowImageLayerOGL::Init(const SharedIm
     return true;
   }
   return false;
 }
 
 void
 ShadowImageLayerOGL::Swap(const SharedImage& aNewFront,
                           SharedImage* aNewBack)
-{
+{ 
   if (!mDestroyed) {
-    if (aNewFront.type() == SharedImage::TSurfaceDescriptor) {
+    if (aNewFront.type() == SharedImage::TSharedImageID) {
+      // We are using ImageBridge protocol. The image data will be queried at render
+      // time in the parent side.
+      mImageID = aNewFront.get_SharedImageID().id();
+      mImageVersion = 0;
+    } else if (aNewFront.type() == SharedImage::TSurfaceDescriptor) {
       nsRefPtr<gfxASurface> surf =
         ShadowLayerForwarder::OpenDescriptor(aNewFront.get_SurfaceDescriptor());
       gfxIntSize size = surf->GetSize();
       if (mSize != size || !mTexImage ||
           mTexImage->GetContentType() != surf->GetContentType()) {
         Init(aNewFront);
       }
       // XXX this is always just ridiculously slow
@@ -763,21 +768,88 @@ ShadowImageLayerOGL::Destroy()
 }
 
 Layer*
 ShadowImageLayerOGL::GetLayer()
 {
   return this;
 }
 
+bool ShadowImageLayerOGL::UploadTextureFromSharedImage(SharedImage* img)
+{
+  if (img == nsnull) {
+    printf("\033[31m;xxxxxxxxxxxxxxx error: image parameter is nil!\n xxxxxxxxxxxxx\033[0m");
+    return false;
+  }
+  if (img->type() != SharedImage::TYUVImage) {
+    printf("\033[31m ----- Wrong SharedImage type!! ------ \033[0m\n");
+    return false;
+  }
+
+  const YUVImage& yuv = img->get_YUVImage();
+
+  nsRefPtr<gfxSharedImageSurface> surfY =
+    gfxSharedImageSurface::Open(yuv.Ydata());
+  nsRefPtr<gfxSharedImageSurface> surfU =
+    gfxSharedImageSurface::Open(yuv.Udata());
+  nsRefPtr<gfxSharedImageSurface> surfV =
+    gfxSharedImageSurface::Open(yuv.Vdata());
+  mPictureRect = yuv.picture();
+
+  gfxIntSize size = surfY->GetSize();
+  gfxIntSize CbCrSize = surfU->GetSize();
+  if (size != mSize || mCbCrSize != CbCrSize || !mYUVTexture[0].IsAllocated()) {
+    
+    mSize = surfY->GetSize();
+    mCbCrSize = surfU->GetSize();
+
+    if (!mYUVTexture[0].IsAllocated()) {
+      mYUVTexture[0].Allocate(gl());
+      mYUVTexture[1].Allocate(gl());
+      mYUVTexture[2].Allocate(gl());
+    }
+
+    NS_ASSERTION(mYUVTexture[0].IsAllocated() &&
+                 mYUVTexture[1].IsAllocated() &&
+                 mYUVTexture[2].IsAllocated(),
+                 "Texture allocation failed!");
+
+    gl()->MakeCurrent();
+    SetClamping(gl(), mYUVTexture[0].GetTextureID());
+    SetClamping(gl(), mYUVTexture[1].GetTextureID());
+    SetClamping(gl(), mYUVTexture[2].GetTextureID());
+  }
+
+  PlanarYCbCrImage::Data data;
+  data.mYChannel = surfY->Data();
+  data.mYStride = surfY->Stride();
+  data.mYSize = surfY->GetSize();
+  data.mCbChannel = surfU->Data();
+  data.mCrChannel = surfV->Data();
+  data.mCbCrStride = surfU->Stride();
+  data.mCbCrSize = surfU->GetSize();
+
+  UploadYUVToTexture(gl(), data, &mYUVTexture[0], &mYUVTexture[1], &mYUVTexture[2]);
+
+  return true;
+}
+
 void
 ShadowImageLayerOGL::RenderLayer(int aPreviousFrameBuffer,
                                  const nsIntPoint& aOffset)
 {
   mOGLManager->MakeCurrent();
+  if (mImageID) {
+    PRUint32 imgVersion = ImageContainerParent::GetSharedImageVersion(mImageID);
+    if (imgVersion != mImageVersion) {
+      SharedImage* img = ImageContainerParent::GetSharedImage(mImageID);
+      if (!UploadTextureFromSharedImage(img)) return;
+      mImageVersion = imgVersion;
+    }
+  } 
 
   if (mTexImage) {
     ShaderProgramOGL *colorProgram =
       mOGLManager->GetProgram(mTexImage->GetShaderProgramType(), GetMaskLayer());
 
     colorProgram->Activate();
     colorProgram->SetTextureUnit(0);
     colorProgram->SetLayerTransform(GetEffectiveTransform());
diff --git a/gfx/layers/opengl/ImageLayerOGL.h b/gfx/layers/opengl/ImageLayerOGL.h
--- a/gfx/layers/opengl/ImageLayerOGL.h
+++ b/gfx/layers/opengl/ImageLayerOGL.h
@@ -171,16 +171,18 @@ public:
 
   virtual void RenderLayer(int aPreviousFrameBuffer,
                            const nsIntPoint& aOffset);
 
   virtual void CleanupResources();
 
 private:
   bool Init(const SharedImage& aFront);
+  bool UploadTextureFromSharedImage(SharedImage* img);
+
 
   nsRefPtr<TextureImage> mTexImage;
   GLTexture mYUVTexture[3];
   gfxIntSize mSize;
   gfxIntSize mCbCrSize;
   nsIntRect mPictureRect;
 };
 
diff --git a/layout/generic/nsVideoFrame.cpp b/layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp
+++ b/layout/generic/nsVideoFrame.cpp
@@ -1,16 +1,18 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* rendering object for the HTML <video> element */
 
+#include "mozilla/layers/ImageContainerChild.h"
+
 #include "nsHTMLParts.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
 #include "nsGkAtoms.h"
 
 #include "nsVideoFrame.h"
 #include "nsHTMLVideoElement.h"
 #include "nsIDOMHTMLVideoElement.h"
@@ -22,16 +24,17 @@
 #include "nsTransform2D.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsImageFrame.h"
 #include "nsIImageLoadingContent.h"
 #include "nsCSSRendering.h"
 #include "nsContentUtils.h"
+#include "mozilla/layers/ShadowLayers.h"
 
 #ifdef ACCESSIBILITY
 #include "nsAccessibilityService.h"
 #endif
 
 using namespace mozilla;
 using namespace mozilla::layers;
 using namespace mozilla::dom;
@@ -193,16 +196,19 @@ nsVideoFrame::BuildLayer(nsDisplayListBu
   nsRefPtr<ImageLayer> layer = static_cast<ImageLayer*>
     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
   if (!layer) {
     layer = aManager->CreateImageLayer();
     if (!layer)
       return nsnull;
   }
 
+  ImageContainerChild* ctnChild = container->GetImageContainerChild();
+  ShadowableLayer* shadowable = layer->AsShadowableLayer();
+
   layer->SetContainer(container);
   layer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(this));
   layer->SetContentFlags(Layer::CONTENT_OPAQUE);
   // Set a transform on the layer to draw the video in the right place
   gfxMatrix transform;
   transform.Translate(r.TopLeft());
   transform.Scale(r.Width()/frameSize.width, r.Height()/frameSize.height);
   layer->SetTransform(gfx3DMatrix::From2D(transform));
diff --git a/widget/xpwidgets/Makefile.in b/widget/xpwidgets/Makefile.in
--- a/widget/xpwidgets/Makefile.in
+++ b/widget/xpwidgets/Makefile.in
@@ -11,16 +11,17 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= widget
 LIBRARY_NAME	= xpwidgets_s
 LIBXUL_LIBRARY  = 1
 
 EXPORTS = \
 		GfxInfoCollector.h \
+		nsBaseWidget.h \
 		$(NULL)
 
 DEFINES += \
   -D_IMPL_NS_WIDGET \
   -DNO_NSPR_10_SUPPORT=1 \
   $(NULL)
 
 CPPSRCS		= \
diff --git a/widget/xpwidgets/nsBaseWidget.cpp b/widget/xpwidgets/nsBaseWidget.cpp
--- a/widget/xpwidgets/nsBaseWidget.cpp
+++ b/widget/xpwidgets/nsBaseWidget.cpp
@@ -1,15 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Util.h"
 
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "mozilla/layers/ImageBridgeParent.h"
 #include "mozilla/layers/CompositorChild.h"
 #include "mozilla/layers/CompositorParent.h"
 #include "nsBaseWidget.h"
 #include "nsDeviceContext.h"
 #include "nsCOMPtr.h"
 #include "nsGfxCIID.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
@@ -887,16 +889,24 @@ void nsBaseWidget::CreateCompositor()
 
     if (shadowManager) {
       ShadowLayerForwarder* lf = lm->AsShadowForwarder();
       if (!lf) {
         delete lm;
         mCompositorChild = nsnull;
         return;
       }
+      if (!ImageBridgeChild::IsCreated()) {
+        mozilla::layers::ImageBridgeChild::Create(new base::Thread("ImageBridgeChild"));
+        mImageBridgeChild = mozilla::layers::ImageBridgeChild::GetSingleton();
+        mImageBridgeParent = new mozilla::layers::ImageBridgeParent(mCompositorParent);
+        mImageBridgeChild->ConnectAsync(mImageBridgeParent);
+        lf->SetImageBridge(mImageBridgeChild);
+      }
+
       lf->SetShadowManager(shadowManager);
       lf->SetParentBackendType(LayerManager::LAYERS_OPENGL);
       lf->SetMaxTextureSize(maxTextureSize);
 
       mLayerManager = lm;
     } else {
       // We don't currently want to support not having a LayersChild
       NS_RUNTIMEABORT("failed to construct LayersChild");
diff --git a/widget/xpwidgets/nsBaseWidget.h b/widget/xpwidgets/nsBaseWidget.h
--- a/widget/xpwidgets/nsBaseWidget.h
+++ b/widget/xpwidgets/nsBaseWidget.h
@@ -18,16 +18,18 @@
 class nsIContent;
 class nsAutoRollup;
 class gfxContext;
 
 namespace mozilla {
 namespace layers {
 class CompositorChild;
 class CompositorParent;
+class ImageBridgeChild;
+class ImageBridgeParent;
 }
 }
 
 namespace base {
 class Thread;
 }
 
 /**
@@ -48,16 +50,20 @@ protected:
   typedef mozilla::layers::CompositorChild CompositorChild;
   typedef mozilla::layers::CompositorParent CompositorParent;
   typedef base::Thread Thread;
 
 public:
   nsBaseWidget();
   virtual ~nsBaseWidget();
   
+  mozilla::layers::ImageBridgeChild* GetImageBridgeChild() const {
+    return mImageBridgeChild;
+  }
+
   NS_DECL_ISUPPORTS
   
   // nsIWidget interface
   NS_IMETHOD              CaptureMouse(bool aCapture);
   NS_IMETHOD              GetClientData(void*& aClientData);
   NS_IMETHOD              SetClientData(void* aClientData);
   NS_IMETHOD              Destroy();
   NS_IMETHOD              SetParent(nsIWidget* aNewParent);
@@ -283,16 +289,18 @@ protected:
   ViewWrapper*      mViewWrapperPtr;
   EVENT_CALLBACK    mEventCallback;
   EVENT_CALLBACK    mViewCallback;
   nsDeviceContext* mContext;
   nsRefPtr<LayerManager> mLayerManager;
   nsRefPtr<LayerManager> mBasicLayerManager;
   nsRefPtr<CompositorChild> mCompositorChild;
   nsRefPtr<CompositorParent> mCompositorParent;
+  mozilla::layers::ImageBridgeChild* mImageBridgeChild;
+  mozilla::layers::ImageBridgeParent* mImageBridgeParent;
   Thread*           mCompositorThread;
   nscolor           mBackground;
   nscolor           mForeground;
   nsCursor          mCursor;
   nsWindowType      mWindowType;
   nsBorderStyle     mBorderStyle;
   bool              mOnDestroyCalled;
   bool              mUseAcceleratedRendering;
