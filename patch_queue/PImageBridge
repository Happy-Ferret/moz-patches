# HG changeset patch
# Parent b48dde6bb4393042981de8c582aa73a4bc8be33a

diff --git a/gfx/layers/ImageLayers.cpp b/gfx/layers/ImageLayers.cpp
--- a/gfx/layers/ImageLayers.cpp
+++ b/gfx/layers/ImageLayers.cpp
@@ -2,17 +2,19 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/ipc/Shmem.h"
 #include "mozilla/ipc/CrossProcessMutex.h"
 #include "ImageLayers.h"
 #include "gfxImageSurface.h"
+#include "gfxSharedImageSurface.h"
 #include "yuv_convert.h"
+#include "mozilla/layers/ImageBridgeChild.h"
 
 #ifdef XP_MACOSX
 #include "nsCoreAnimationSupport.h"
 #endif
 
 #ifdef XP_WIN
 #include "gfxD2DSurface.h"
 #include "gfxWindowsPlatform.h"
@@ -106,16 +108,79 @@ ImageContainer::SetCurrentImage(Image *a
   mActiveImage = aImage;
   CurrentImageChanged();
 
   if (mRemoteData) {
     mRemoteDataMutex->Unlock();
   }
 }
 
+void
+ImageContainer::SetCurrentImageAsync(Image *aImage)
+{
+  if (!mImageBridgeChild) return;
+  // TODO
+
+  // Copy aImage into a SharedImage 
+
+}
+
+void ImageContainer::CopyImageToShmem(Image * image)
+{
+  // TODO: this is copy-pasted from BasciLayers.cpp and will be modified
+  // to fit the ImageContainer's needs
+
+  // TODO: here's a bunch of variables that need to be set to the righ value
+  gfxIntSize size;
+  nsRefPtr<gfxSharedImageSurface> mBackBufferY;
+  nsRefPtr<gfxSharedImageSurface> mBackBufferU;
+  nsRefPtr<gfxSharedImageSurface> mBackBufferV;
+  // TODO: I don't test for BasicManager()->IsCompositingCheap() here,
+  // is this a problem?
+  if (image->GetFormat() == Image::PLANAR_YCBCR ) {
+    PlanarYCbCrImage *YCbCrImage = static_cast<PlanarYCbCrImage*>(image);
+    const PlanarYCbCrImage::Data *data = YCbCrImage->GetData();
+    NS_ASSERTION(data, "Must be able to retrieve yuv data from image!");
+
+    //DestroyBackBuffer();
+    size = data->mYSize;
+    //mCbCrSize = data->mCbCrSize;
+
+    if (!mImageBridgeChild->AllocBuffer(size, gfxASurface::CONTENT_ALPHA,
+                                   getter_AddRefs(mBackBufferY)) ||
+        !mImageBridgeChild->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                                   getter_AddRefs(mBackBufferU)) ||
+        !mImageBridgeChild->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                                   getter_AddRefs(mBackBufferV))) {
+      NS_RUNTIMEABORT("creating ImageLayer 'front buffer' failed!");
+    }
+
+    for (int i = 0; i < data->mYSize.height; i++) {
+      memcpy(mBackBufferY->Data() + i * mBackBufferY->Stride(),
+             data->mYChannel + i * data->mYStride,
+             data->mYSize.width);
+    }
+    for (int i = 0; i < data->mCbCrSize.height; i++) {
+      memcpy(mBackBufferU->Data() + i * mBackBufferU->Stride(),
+             data->mCbChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+      memcpy(mBackBufferV->Data() + i * mBackBufferV->Stride(),
+             data->mCrChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+    }
+
+    ImageBridgeChild::YUVImage yuv(mBackBufferY->GetShmem(),
+                 mBackBufferU->GetShmem(),
+                 mBackBufferV->GetShmem(),
+                 data->GetPictureRect());
+
+    // TODO: do something with yuv!
+  }
+}
+
 bool
 ImageContainer::HasCurrentImage()
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
   if (mRemoteData) {
     CrossProcessMutexAutoLock autoLock(*mRemoteDataMutex);
     
diff --git a/gfx/layers/ImageLayers.h b/gfx/layers/ImageLayers.h
--- a/gfx/layers/ImageLayers.h
+++ b/gfx/layers/ImageLayers.h
@@ -11,16 +11,17 @@
 #include "nsISupportsImpl.h"
 #include "gfxPattern.h"
 #include "nsThreadUtils.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/mozalloc.h"
 #include "mozilla/Mutex.h"
 #include "gfxPlatform.h"
+#include "mozilla/LinkedList.h"
 
 #ifdef XP_MACOSX
 #include "nsIOSurface.h"
 #endif
 #ifdef XP_WIN
 struct ID3D10Texture2D;
 struct ID3D10Device;
 struct ID3D10ShaderResourceView;
@@ -32,16 +33,19 @@ namespace mozilla {
 
 class CrossProcessMutex;
 namespace ipc {
 class Shmem;
 }
 
 namespace layers {
 
+class ImageBridgeChild;
+class SharedImage;
+
 enum StereoMode {
   STEREO_MODE_MONO,
   STEREO_MODE_LEFT_RIGHT,
   STEREO_MODE_RIGHT_LEFT,
   STEREO_MODE_BOTTOM_TOP,
   STEREO_MODE_TOP_BOTTOM
 };
 
@@ -278,29 +282,32 @@ struct RemoteImageData {
 
 /**
  * A class that manages Images for an ImageLayer. The only reason
  * we need a separate class here is that ImageLayers aren't threadsafe
  * (because layers can only be used on the main thread) and we want to
  * be able to set the current Image from any thread, to facilitate
  * video playback without involving the main thread, for example.
  */
-class THEBES_API ImageContainer {
+class THEBES_API ImageContainer : public LinkedListElement<ImageContainer> 
+{
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainer)
-
+  friend class mozilla::layers::ImageBridgeChild;
 public:
   ImageContainer() :
     mReentrantMonitor("ImageContainer.mReentrantMonitor"),
     mPaintCount(0),
     mPreviousImagePainted(false),
     mImageFactory(new ImageFactory()),
     mRecycleBin(new BufferRecycleBin()),
     mRemoteData(nsnull),
     mRemoteDataMutex(nsnull),
-    mCompositionNotifySink(nsnull)
+    mCompositionNotifySink(nsnull),
+    mImageBridgeChild(nsnull),
+    mLayerID(0)
   {}
 
   ~ImageContainer();
 
   /**
    * Create an Image in one of the given formats.
    * Picks the "best" format from the list and creates an Image of that
    * format.
@@ -321,16 +328,26 @@ public:
    * The Image data must not be modified after this method is called!
    *
    * Implementations must call CurrentImageChanged() while holding
    * mReentrantMonitor.
    */
   void SetCurrentImage(Image* aImage);
 
   /**
+   * Schelude a task to set an image as the current Image to display
+   * using the PImageBridge protcol.
+   *
+   * The Image data must not be modified after this method is called!
+   *
+   * Can be called from any thread.
+   */
+  void SetCurrentImageAsync(Image* aImage);
+
+  /**
    * Returns if the container currently has an image.
    * Can be called on any thread. This method takes mReentrantMonitor
    * when accessing thread-shared state.
    */
   bool HasCurrentImage();
 
   /**
    * Lock the current Image.
@@ -469,16 +486,34 @@ public:
   void SetRemoteImageData(RemoteImageData *aRemoteData,
                           CrossProcessMutex *aRemoteDataMutex);
   /**
    * This can be used to check if the container has RemoteData set.
    */
   RemoteImageData *GetRemoteImageData() { return mRemoteData; }
 
 protected:
+
+  ImageBridgeChild * GetImageBridgeChild() const 
+  {
+    return mImageBridgeChild;
+  }
+  void SetImageBridgeChild(ImageBridgeChild * aBridge)
+  {
+    mImageBridgeChild = aBridge;
+  }
+
+  PRInt32 GetLayerID() const { return mLayerID; }
+  void SetLayerID(PRInt32 aLayerID)
+  { 
+    mLayerID = aLayerID; 
+  }
+
+  void CopyImageToShmem(Image * aImage);
+
   typedef mozilla::ReentrantMonitor ReentrantMonitor;
 
   // This is called to ensure we have an active image, this may not be true
   // when we're storing image information in a RemoteImageData structure.
   // NOTE: If we have remote data mRemoteDataMutex should be locked when
   // calling this function!
   void EnsureActiveImage();
 
@@ -524,16 +559,20 @@ protected:
   RemoteImageData *mRemoteData;
 
   // This cross-process mutex is used to synchronise access to mRemoteData.
   // When this mutex is held, we will always be inside the mReentrantMonitor
   // however the same is not true vice versa.
   CrossProcessMutex *mRemoteDataMutex;
 
   CompositionNotifySink *mCompositionNotifySink;
+
+  // ImageBridgeProtocol
+  ImageBridgeChild * mImageBridgeChild;
+  PRInt32 mLayerID;
 };
  
 class AutoLockImage
 {
 public:
   AutoLockImage(ImageContainer *aContainer) : mContainer(aContainer) { mImage = mContainer->LockCurrentImage(); }
   AutoLockImage(ImageContainer *aContainer, gfxASurface **aSurface) : mContainer(aContainer) {
     *aSurface = mContainer->LockCurrentAsSurface(&mSize, getter_AddRefs(mImage)).get();
diff --git a/gfx/layers/Makefile.in b/gfx/layers/Makefile.in
--- a/gfx/layers/Makefile.in
+++ b/gfx/layers/Makefile.in
@@ -105,27 +105,31 @@ EXPORTS_mozilla/layers =\
         CompositorCocoaWidgetHelper.h \
         CompositorChild.h \
         CompositorParent.h \
         ShadowLayers.h \
         ShadowLayersChild.h \
         ShadowLayersParent.h \
         ShadowLayersManager.h \
         RenderTrace.h \
+        ImageBridgeChild.h \
+        ImageBridgeParent.h \
         $(NULL)
 
 CPPSRCS += \
         CompositorCocoaWidgetHelper.cpp \
         CompositorChild.cpp \
         CompositorParent.cpp \
         ShadowLayers.cpp \
         ShadowLayerChild.cpp \
         ShadowLayersChild.cpp \
         ShadowLayerParent.cpp \
         ShadowLayersParent.cpp \
+        ImageBridgeChild.cpp \
+        ImageBridgeParent.cpp \
         $(NULL)
 
 ifdef MOZ_X11 #{
 EXPORTS_mozilla/layers += ShadowLayerUtilsX11.h
 CPPSRCS += ShadowLayerUtilsX11.cpp
 endif #}
 
 ifdef MOZ_ENABLE_D3D10_LAYER
diff --git a/gfx/layers/ipc/ImageBridgeChild.cpp b/gfx/layers/ipc/ImageBridgeChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.cpp
@@ -0,0 +1,163 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageBridgeChild.h"
+#include "ImageBridgeParent.h"
+#include "gfxSharedImageSurface.h"
+
+#include "base/thread.h"
+
+// temporary: kinda nice for me while the patch is not 
+// finished, will be removed
+#ifdef __GNUG__
+#define NOT_IMPLEMENTED printf("\033[1;34m %s is not implemented!\033[0m\n", __PRETTY_FUNCTION__);
+#else
+#define NOT_IMPLEMENTED   
+#endif
+
+namespace mozilla {
+namespace layers {
+
+ImageBridgeChild::ImageBridgeChild(base::Thread& aThread)
+{
+  mThread = &aThread;
+  if (!mThread->IsRunning()) {
+    mThread->Start();
+  }
+}
+
+ImageBridgeChild::~ImageBridgeChild()
+{
+  RemoveAllImageContainers();
+}
+
+
+// IPDL protocol
+
+
+bool ImageBridgeChild::RecvReleasedSharedImage(const LayerID_t& aLayerID, 
+                                               const ImageBridgeChild::SharedImage& aImage)
+{
+  printf("\033[1;34m -- ImageBridgeChild: received an image (layerID: %i) \033[0m\n", aLayerID);
+  NOT_IMPLEMENTED
+  return true;
+}
+
+bool ImageBridgeChild::AllocSharedImage(const gfxIntSize& aSize,
+                                        gfxASurface::gfxContentType aContent,
+                                        ImageBridgeChild::SharedImage& aImage)
+{
+  // TODO
+  NOT_IMPLEMENTED
+  return false;
+}
+
+void ImageBridgeChild::DestroySharedImage(ImageBridgeChild::SharedImage& aImage)
+{
+  NOT_IMPLEMENTED
+  // TODO
+}
+
+bool ImageBridgeChild::InImageBridgeChildThread() const {
+  return mThread->thread_id() == PlatformThread::CurrentId();
+}
+
+void ImageBridgeChild::AddImageContainer(ImageContainer& aImageContainer)
+{
+  NS_ASSERTION(InImageBridgeChildThread(),"Shoudl be in ImageBridgeChild thread!");
+  mImageContainers.insertBack(&aImageContainer);
+  aImageContainer.SetImageBridgeChild(this);
+}
+
+void ImageBridgeChild::RemoveImageContainer(ImageContainer& aImageContainer)
+{
+  NS_ASSERTION(InImageBridgeChildThread(),"Shoudl be in ImageBridgeChild thread!");
+  aImageContainer.remove();
+  aImageContainer.SetImageBridgeChild(nsnull);
+}
+
+void ImageBridgeChild::RemoveAllImageContainers()
+{
+  NS_ASSERTION(InImageBridgeChildThread(),"Shoudl be in ImageBridgeChild thread!");
+  ImageContainer * it = mImageContainers.getFirst();
+  while (it != nsnull) {
+    RemoveImageContainer(*it);
+    it = it->getNext();
+  }
+}
+
+
+bool ImageBridgeChild::AllocBuffer(const gfxIntSize& aSize,
+                              gfxASurface::gfxContentType aContent,
+                              gfxSharedImageSurface** aBuffer)
+{
+  SharedMemory::SharedMemoryType shmemType = ipc::OptimalShmemType();
+  gfxASurface::gfxImageFormat format = gfxPlatform::GetPlatform()->OptimalFormatForContent(aContent);
+
+  nsRefPtr<gfxSharedImageSurface> back =
+    gfxSharedImageSurface::CreateUnsafe(this, aSize, format, shmemType);
+  if (!back)
+    return false;
+
+  *aBuffer = nsnull;
+  back.swap(*aBuffer);
+  return true;
+}
+
+
+// async opertations:
+
+class ImageBridgeConnectionTask : public Task
+{
+public:
+ImageBridgeConnectionTask(ImageBridgeChild * child, ImageBridgeParent * parent)
+  : mChild(child), mParent(parent) {}
+
+  void Run()
+  {
+    MessageLoop * parentMsgLoop = mParent->GetThread()->message_loop();
+    ipc::AsyncChannel * parentChannel = mParent->GetIPCChannel();
+    mChild->Open(parentChannel, parentMsgLoop, mozilla::ipc::AsyncChannel::Child);
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageBridgeParent * mParent;
+};
+
+class ImageBridgeSendTask : public Task
+{
+public:
+  ImageBridgeSendTask(ImageBridgeChild * child, 
+                      PRInt32 aLayerID,
+                      ImageBridgeChild::SharedImage * aImage)
+  : mChild(child), mImage(aImage), mLayerID(aLayerID) {}
+
+  void Run()
+  {
+    mChild->SendPushSharedImage(mLayerID, *mImage);
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageBridgeChild::SharedImage * mImage;
+  PRInt32 mLayerID;
+};
+
+void ImageBridgeChild::AsyncConnect(ImageBridgeParent& aParent)
+{
+  Task * t = new ImageBridgeConnectionTask(this, &aParent);
+  GetThread()->message_loop()->PostTask(FROM_HERE, t);
+}
+
+void ImageBridgeChild::AsyncSendSharedImage(PRInt32 aLayerID,
+                                            ImageBridgeChild::SharedImage& aImage)
+{
+  Task * t = new ImageBridgeSendTask(this, aLayerID, &aImage);
+  GetThread()->message_loop()->PostTask(FROM_HERE, t);
+}
+
+
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeChild.h b/gfx/layers/ipc/ImageBridgeChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.h
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/PImageBridgeChild.h"
+#include "mozilla/LinkedList.h" 
+#include "ImageLayers.h" 
+
+class gfxSharedImageSurface;
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeParent;
+
+class ImageBridgeChild : public PImageBridgeChild
+{
+// NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VideoBridgeChild)
+friend class mozilla::layers::ImageContainer;
+public:
+  typedef PRInt32 CompositorID_t;
+  typedef PRInt32 LayerID_t;
+  typedef MediaSharedImage SharedImage;
+  typedef MediaSurfaceDescriptor SurfaceDescriptor;
+  typedef MediaYUVImage YUVImage;
+
+  ImageBridgeChild(base::Thread& aThread);
+  ~ImageBridgeChild();
+
+  // IPDL protocol
+
+  // override
+  virtual bool RecvReleasedSharedImage(const LayerID_t& aLayerID, 
+                                       const SharedImage& aImage);
+  
+  // Temporary, not suitable for cross-process layers
+  // can be called from any thread
+  void AsyncConnect(ImageBridgeParent& aParent);
+
+  
+  /**
+   * Returns the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  base::Thread * GetThread() const
+  {
+    return mThread;
+  }
+
+  /**
+   * Returns true if the current thread is the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  bool InImageBridgeChildThread() const;
+
+private:
+
+  /**
+   * Dispatch a task in the ImageBridgeChild thread to send an 
+   * image through IPC to the compositor.
+   *
+   * Can be called from any thread.
+   */
+  void AsyncSendSharedImage(PRInt32 aLayerID, SharedImage& aSurface);
+
+  /**
+   * Same as ShadowLayerForwarder::AllocBuffer.
+   *
+   * TODO: better doc
+   */
+  bool AllocBuffer(const gfxIntSize& aSize,
+              gfxASurface::gfxContentType aContent,
+              gfxSharedImageSurface** aBuffer);
+
+  bool AllocSharedImage(const gfxIntSize& aSize,
+                        gfxASurface::gfxContentType aContent,
+                        SharedImage& aImage);
+
+  void DestroySharedImage(SharedImage& aSurface);
+
+  void AddImageContainer(ImageContainer& aImageContainer);
+  void RemoveImageContainer(ImageContainer& aImageContainer);
+  void RemoveAllImageContainers();
+
+  base::Thread * mThread;
+  // TODO: LinkedList is not thread-safe. It is not clear at the 
+  // moment whether this part of the class will be accessed from 
+  // several threads. If so, need a thread save solution 
+  // Ideally it should be accessed only from within the 
+  // ImageBridgeChild thread/
+  LinkedList<ImageContainer> mImageContainers;
+};
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.cpp b/gfx/layers/ipc/ImageBridgeParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.cpp
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageBridgeParent.h"
+
+#include "base/thread.h"
+
+namespace mozilla {
+namespace layers {
+
+bool ImageBridgeParent::RecvPushSharedImage(const LayerID_t& aLayerID, 
+                                            const MediaSharedImage& aImage)
+{
+  printf("ImageBridgeParent::RecvPushSharedImage (layerID: %i)\n", aLayerID);
+  // TODO
+  SendReleasedSharedImage(aLayerID,aImage);
+  return true;
+}
+
+ImageBridgeParent::ImageBridgeParent(base::Thread& aThread)
+: mThread(&aThread)
+{
+
+}
+
+
+ImageBridgeParent::~ImageBridgeParent()
+{
+  RemoveAllShadowImageLayers();
+}
+
+void ImageBridgeParent::AddShadowImageLayer(ShadowImageLayer& aLayer)
+{
+  mShadowLayers.insertBack(&aLayer);
+  aLayer.SetImageBridgeParent(this);
+}
+
+void ImageBridgeParent::RemoveShadowImageLayer(ShadowImageLayer& aLayer)
+{
+  aLayer.SetImageBridgeParent(nsnull);
+  aLayer.remove();
+}
+
+void ImageBridgeParent::RemoveAllShadowImageLayers()
+{
+  ShadowImageLayer * it = mShadowLayers.getFirst();
+  while (it != nsnull) {
+    RemoveShadowImageLayer(*it);
+  }
+}
+
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.h b/gfx/layers/ipc/ImageBridgeParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/PImageBridgeParent.h"
+#include "ShadowLayers.h"
+
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeChild;
+
+class ImageBridgeParent : public PImageBridgeParent
+{
+// NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VideoBridgeChild)
+public:
+  typedef PRInt32 CompositorID_t;
+  typedef PRInt32 LayerID_t;
+  typedef MediaSharedImage SharedImage;
+  // IPDL protocol
+
+  ImageBridgeParent(base::Thread& aThread);
+  ~ImageBridgeParent();
+
+  // override
+  virtual bool RecvPushSharedImage(const LayerID_t& aLayerID, 
+                                   const SharedImage& aImage);
+
+  // -------------
+
+
+  base::Thread * GetThread() const
+  {
+    return mThread;
+  }
+
+private:
+  void AddShadowImageLayer(ShadowImageLayer& aLayer);
+  void RemoveShadowImageLayer(ShadowImageLayer& aLayer);
+  void RemoveAllShadowImageLayers();
+
+  base::Thread * mThread; //should be the compositor thread
+  LinkedList<ShadowImageLayer> mShadowLayers;
+  // TODO: a list of ShadowImageLayers here
+};
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/PImageBridge.ipdl b/gfx/layers/ipc/PImageBridge.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PImageBridge.ipdl
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include "gfxipc/ShadowLayerUtils.h";
+
+using nsIntPoint;
+using nsIntRect;
+using nsIntRegion;
+using nsIntSize;
+using mozilla::layers::SurfaceDescriptorX11;
+using mozilla::null_t;
+using mozilla::WindowsHandle;
+
+namespace mozilla {
+namespace layers {
+
+struct MediaSurfaceDescriptorD3D10 {
+  WindowsHandle handle;
+};
+
+union MediaSurfaceDescriptor {
+  Shmem;
+  MediaSurfaceDescriptorD3D10;
+  SurfaceDescriptorX11;
+};
+
+struct MediaYUVImage {
+  Shmem Ydata;
+  Shmem Udata;
+  Shmem Vdata;
+  nsIntRect picture;
+};
+
+union MediaSharedImage {
+  MediaSurfaceDescriptor;
+  MediaYUVImage;
+  null_t;
+};
+
+/**
+ * The PImageBridge protocol is used to allow isolated threads or processes to push
+ * frames directly to the compositor thread/process without relying on the main thread
+ * which might be too busy dealing with content script.
+ */
+async protocol PImageBridge
+{
+parent:
+    // Send a SharedImage to the compositor giving to the compositor ownership 
+    // of the image.
+    PushSharedImage(PRInt32 layerID, MediaSharedImage image);
+
+child:
+    // Give back the child thread/process ownership to a SharedImage
+    ReleasedSharedImage(PRInt32 layerID, MediaSharedImage image);
+};
+
+
+} //namespace
+} //namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/ShadowLayers.h b/gfx/layers/ipc/ShadowLayers.h
--- a/gfx/layers/ipc/ShadowLayers.h
+++ b/gfx/layers/ipc/ShadowLayers.h
@@ -7,16 +7,17 @@
 
 #ifndef mozilla_layers_ShadowLayers_h
 #define mozilla_layers_ShadowLayers_h 1
 
 #include "gfxASurface.h"
 
 #include "ImageLayers.h"
 #include "Layers.h"
+#include "mozilla/LinkedList.h"
 
 class gfxSharedImageSurface;
 
 namespace mozilla {
 namespace layers {
 
 class Edit;
 class EditReply;
@@ -32,16 +33,17 @@ class ShadowColorLayer;
 class ShadowCanvasLayer;
 class SurfaceDescriptor;
 class ThebesBuffer;
 class TiledLayerComposer;
 class Transaction;
 class SharedImage;
 class CanvasSurface;
 class BasicTiledLayerBuffer;
+class ImageBridgeParent;
 
 /**
  * We want to share layer trees across thread contexts and address
  * spaces for several reasons; chief among them
  *
  *  - a parent process can paint a child process's layer tree while
  *    the child process is blocked, say on content script.  This is
  *    important on mobile devices where UI responsiveness is key.
@@ -561,35 +563,54 @@ public:
 
 protected:
   ShadowCanvasLayer(LayerManager* aManager, void* aImplData)
     : CanvasLayer(aManager, aImplData)
   {}
 };
 
 
-class ShadowImageLayer : public ShadowLayer,
+class ShadowImageLayer : public LinkedListElement<ShadowImageLayer>,
+                         public ShadowLayer,
                          public ImageLayer
 {
+friend class mozilla::layers::ImageBridgeParent;
 public:
   /**
    * CONSTRUCTION PHASE ONLY
    * @see ShadowCanvasLayer::Swap
    */
   virtual void Swap(const SharedImage& aFront,
                     SharedImage* aNewBack) = 0;
 
   virtual ShadowLayer* AsShadowLayer() { return this; }
 
   MOZ_LAYER_DECL_NAME("ShadowImageLayer", TYPE_SHADOW)
 
 protected:
   ShadowImageLayer(LayerManager* aManager, void* aImplData)
     : ImageLayer(aManager, aImplData)
   {}
+
+  // called by ImageBridgeParent
+  ImageBridgeParent * GetImageBridgeParent() const 
+  {
+    return mImageBridgeParent;
+  }
+  // called by ImageBridgeParent
+  void SetImageBridgeParent(ImageBridgeParent * aBridge)
+  {
+    mImageBridgeParent = aBridge;
+  }
+  // called by ImageBridgeParent
+  PRInt32 GetLayerID() const { return mLayerID; }
+  void SetLayerID(PRInt32 aID) { mLayerID = aID; }
+
+  ImageBridgeParent * mImageBridgeParent;
+  PRInt32 mLayerID;
 };
 
 
 class ShadowColorLayer : public ShadowLayer,
                          public ColorLayer
 {
 public:
   virtual ShadowLayer* AsShadowLayer() { return this; }
diff --git a/gfx/layers/ipc/ipdl.mk b/gfx/layers/ipc/ipdl.mk
--- a/gfx/layers/ipc/ipdl.mk
+++ b/gfx/layers/ipc/ipdl.mk
@@ -1,9 +1,10 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 IPDLSRCS = \
   PCompositor.ipdl \
   PLayer.ipdl \
   PLayers.ipdl \
+  PImageBridge.ipdl \
   $(NULL)
