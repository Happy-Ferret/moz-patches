# HG changeset patch
# Parent afc6e7a543f274890574ba897ad51cada286dcc4

diff --git a/content/html/content/src/nsHTMLMediaElement.cpp b/content/html/content/src/nsHTMLMediaElement.cpp
--- a/content/html/content/src/nsHTMLMediaElement.cpp
+++ b/content/html/content/src/nsHTMLMediaElement.cpp
@@ -1,16 +1,18 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Util.h"
 
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "mozilla/layers/ImageContainerChild.h"
 #include "nsIDOMHTMLMediaElement.h"
 #include "nsIDOMHTMLSourceElement.h"
 #include "nsHTMLMediaElement.h"
 #include "nsTimeRanges.h"
 #include "nsGenericHTMLElement.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
 #include "nsGkAtoms.h"
@@ -2989,16 +2991,18 @@ VideoFrameContainer* nsHTMLMediaElement:
 
   // Only video frames need an image container.
   nsCOMPtr<nsIDOMHTMLVideoElement> video = do_QueryObject(this);
   if (!video)
     return nsnull;
 
   mVideoFrameContainer =
     new VideoFrameContainer(this, LayerManager::CreateImageContainer());
+  mozilla::layers::ImageContainerChild* child = mozilla::layers::ImageBridgeChild::_hack_GetBridge()->CreateImageContainerChild();
+  mVideoFrameContainer->GetImageContainer()->SetImageContainerChild(child);
   return mVideoFrameContainer;
 }
 
 nsresult nsHTMLMediaElement::DispatchAudioAvailableEvent(float* aFrameBuffer,
                                                          PRUint32 aFrameBufferLength,
                                                          float aTime)
 {
   // Auto manage the memory for the frame buffer. If we fail and return
diff --git a/content/media/VideoFrameContainer.cpp b/content/media/VideoFrameContainer.cpp
--- a/content/media/VideoFrameContainer.cpp
+++ b/content/media/VideoFrameContainer.cpp
@@ -27,16 +27,17 @@ void VideoFrameContainer::SetCurrentFram
   }
 
   gfxIntSize oldFrameSize = mImageContainer->GetCurrentSize();
   TimeStamp lastPaintTime = mImageContainer->GetPaintTime();
   if (!lastPaintTime.IsNull() && !mPaintTarget.IsNull()) {
     mPaintDelay = lastPaintTime - mPaintTarget;
   }
   mImageContainer->SetCurrentImage(aImage);
+  mImageContainer->SetCurrentImageAsync(aImage);
   gfxIntSize newFrameSize = mImageContainer->GetCurrentSize();
   if (oldFrameSize != newFrameSize) {
     mImageSizeChanged = true;
   }
 
   mPaintTarget = aTargetTime;
 }
 
diff --git a/gfx/layers/ImageLayers.cpp b/gfx/layers/ImageLayers.cpp
--- a/gfx/layers/ImageLayers.cpp
+++ b/gfx/layers/ImageLayers.cpp
@@ -2,17 +2,19 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/ipc/Shmem.h"
 #include "mozilla/ipc/CrossProcessMutex.h"
 #include "ImageLayers.h"
 #include "gfxImageSurface.h"
+#include "gfxSharedImageSurface.h"
 #include "yuv_convert.h"
+#include "mozilla/layers/ImageContainerChild.h"
 
 #ifdef XP_MACOSX
 #include "nsCoreAnimationSupport.h"
 #endif
 
 #ifdef XP_WIN
 #include "gfxD2DSurface.h"
 #include "gfxWindowsPlatform.h"
@@ -107,16 +109,26 @@ ImageContainer::SetCurrentImage(Image *a
   CurrentImageChanged();
 
   if (mRemoteData) {
     mRemoteDataMutex->Unlock();
   }
 }
 
 bool
+ImageContainer::SetCurrentImageAsync(Image * aImage)
+{
+  if (!mImageContainerChild) return false;
+  // TODO do we need to actually keep a ref to the image ?
+  // inthis case maybe we need a lock here also (if we do need to keep a reference)
+  mImageContainerChild->SendImageAsync(aImage);
+  return true;
+}
+
+bool
 ImageContainer::HasCurrentImage()
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
   if (mRemoteData) {
     CrossProcessMutexAutoLock autoLock(*mRemoteDataMutex);
     
     EnsureActiveImage();
diff --git a/gfx/layers/ImageLayers.h b/gfx/layers/ImageLayers.h
--- a/gfx/layers/ImageLayers.h
+++ b/gfx/layers/ImageLayers.h
@@ -32,16 +32,20 @@ namespace mozilla {
 
 class CrossProcessMutex;
 namespace ipc {
 class Shmem;
 }
 
 namespace layers {
 
+class ImageContainerChild;
+class SharedImage;
+class MediaSharedImage;
+
 enum StereoMode {
   STEREO_MODE_MONO,
   STEREO_MODE_LEFT_RIGHT,
   STEREO_MODE_RIGHT_LEFT,
   STEREO_MODE_BOTTOM_TOP,
   STEREO_MODE_TOP_BOTTOM
 };
 
@@ -278,29 +282,30 @@ struct RemoteImageData {
 
 /**
  * A class that manages Images for an ImageLayer. The only reason
  * we need a separate class here is that ImageLayers aren't threadsafe
  * (because layers can only be used on the main thread) and we want to
  * be able to set the current Image from any thread, to facilitate
  * video playback without involving the main thread, for example.
  */
-class THEBES_API ImageContainer {
+class THEBES_API ImageContainer 
+{
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainer)
-
 public:
   ImageContainer() :
     mReentrantMonitor("ImageContainer.mReentrantMonitor"),
     mPaintCount(0),
     mPreviousImagePainted(false),
     mImageFactory(new ImageFactory()),
     mRecycleBin(new BufferRecycleBin()),
     mRemoteData(nsnull),
     mRemoteDataMutex(nsnull),
-    mCompositionNotifySink(nsnull)
+    mCompositionNotifySink(nsnull),
+    mImageContainerChild(nsnull)
   {}
 
   ~ImageContainer();
 
   /**
    * Create an Image in one of the given formats.
    * Picks the "best" format from the list and creates an Image of that
    * format.
@@ -321,16 +326,26 @@ public:
    * The Image data must not be modified after this method is called!
    *
    * Implementations must call CurrentImageChanged() while holding
    * mReentrantMonitor.
    */
   void SetCurrentImage(Image* aImage);
 
   /**
+   * Schelude a task to set an image as the current Image to display
+   * using the PImageBridge protcol.
+   *
+   * The Image data must not be modified after this method is called!
+   *
+   * Can be called from any thread.
+   */
+  bool SetCurrentImageAsync(Image* aImage);
+
+  /**
    * Returns if the container currently has an image.
    * Can be called on any thread. This method takes mReentrantMonitor
    * when accessing thread-shared state.
    */
   bool HasCurrentImage();
 
   /**
    * Lock the current Image.
@@ -468,17 +483,31 @@ public:
    */
   void SetRemoteImageData(RemoteImageData *aRemoteData,
                           CrossProcessMutex *aRemoteDataMutex);
   /**
    * This can be used to check if the container has RemoteData set.
    */
   RemoteImageData *GetRemoteImageData() { return mRemoteData; }
 
+  // -------------- Async Image transfer
+  
+  ImageContainerChild * GetImageContainerChild() const 
+  {
+    return mImageContainerChild;
+  }
+  void SetImageContainerChild(ImageContainerChild * aChild)
+  {
+    mImageContainerChild = aChild;
+  }
+
 protected:
+
+  // --------------
+
   typedef mozilla::ReentrantMonitor ReentrantMonitor;
 
   // This is called to ensure we have an active image, this may not be true
   // when we're storing image information in a RemoteImageData structure.
   // NOTE: If we have remote data mRemoteDataMutex should be locked when
   // calling this function!
   void EnsureActiveImage();
 
@@ -524,16 +553,19 @@ protected:
   RemoteImageData *mRemoteData;
 
   // This cross-process mutex is used to synchronise access to mRemoteData.
   // When this mutex is held, we will always be inside the mReentrantMonitor
   // however the same is not true vice versa.
   CrossProcessMutex *mRemoteDataMutex;
 
   CompositionNotifySink *mCompositionNotifySink;
+
+  // ImageBridgeProtocol
+  ImageContainerChild * mImageContainerChild;
 };
  
 class AutoLockImage
 {
 public:
   AutoLockImage(ImageContainer *aContainer) : mContainer(aContainer) { mImage = mContainer->LockCurrentImage(); }
   AutoLockImage(ImageContainer *aContainer, gfxASurface **aSurface) : mContainer(aContainer) {
     *aSurface = mContainer->LockCurrentAsSurface(&mSize, getter_AddRefs(mImage)).get();
diff --git a/gfx/layers/Makefile.in b/gfx/layers/Makefile.in
--- a/gfx/layers/Makefile.in
+++ b/gfx/layers/Makefile.in
@@ -105,27 +105,35 @@ EXPORTS_mozilla/layers =\
         CompositorCocoaWidgetHelper.h \
         CompositorChild.h \
         CompositorParent.h \
         ShadowLayers.h \
         ShadowLayersChild.h \
         ShadowLayersParent.h \
         ShadowLayersManager.h \
         RenderTrace.h \
+        ImageBridgeChild.h \
+        ImageBridgeParent.h \
+        ImageContainerChild.h \
+        ImageContainerParent.h \
         $(NULL)
 
 CPPSRCS += \
         CompositorCocoaWidgetHelper.cpp \
         CompositorChild.cpp \
         CompositorParent.cpp \
         ShadowLayers.cpp \
         ShadowLayerChild.cpp \
         ShadowLayersChild.cpp \
         ShadowLayerParent.cpp \
         ShadowLayersParent.cpp \
+        ImageBridgeChild.cpp \
+        ImageBridgeParent.cpp \
+        ImageContainerChild.cpp \
+        ImageContainerParent.cpp \
         $(NULL)
 
 ifdef MOZ_X11 #{
 EXPORTS_mozilla/layers += ShadowLayerUtilsX11.h
 CPPSRCS += ShadowLayerUtilsX11.cpp
 endif #}
 
 ifdef MOZ_ENABLE_D3D10_LAYER
diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp
--- a/gfx/layers/basic/BasicLayers.cpp
+++ b/gfx/layers/basic/BasicLayers.cpp
@@ -2607,16 +2607,18 @@ private:
   nsRefPtr<gfxSharedImageSurface> mBackBufferU;
   nsRefPtr<gfxSharedImageSurface> mBackBufferV;
   gfxIntSize mCbCrSize;
 };
  
 void
 BasicShadowableImageLayer::Paint(gfxContext* aContext, Layer* aMaskLayer)
 {
+  return; // nical 
+  
   if (!HasShadow()) {
     BasicImageLayer::Paint(aContext, aMaskLayer);
     return;
   }
 
   if (!mContainer) {
     return;
   }
diff --git a/gfx/layers/ipc/CompositorParent.cpp b/gfx/layers/ipc/CompositorParent.cpp
--- a/gfx/layers/ipc/CompositorParent.cpp
+++ b/gfx/layers/ipc/CompositorParent.cpp
@@ -204,17 +204,20 @@ CompositorParent::ScheduleTask(Cancelabl
   } else {
     MessageLoop::current()->PostDelayedTask(FROM_HERE, task, time);
   }
 }
 
 void
 CompositorParent::ScheduleComposition()
 {
+
+  printf("CompositorParent::ScheduleComposition\n");
   if (mCurrentCompositeTask) {
+    printf("already mCurrentCompositeTask\n");
     return;
   }
 
   bool initialComposition = mLastCompose.IsNull();
   TimeDuration delta;
   if (!initialComposition)
     delta = mozilla::TimeStamp::Now() - mLastCompose;
 
@@ -242,39 +245,43 @@ CompositorParent::SetTransformation(floa
   mXScale = aScale;
   mYScale = aScale;
   mScrollOffset = aScrollOffset;
 }
 
 void
 CompositorParent::Composite()
 {
+  printf("Begin CompositorParent::Composite\n");
   NS_ABORT_IF_FALSE(CompositorThreadID() == PlatformThread::CurrentId(),
                     "Composite can only be called on the compositor thread");
   mCurrentCompositeTask = NULL;
 
   mLastCompose = mozilla::TimeStamp::Now();
 
   if (mPaused || !mLayerManager || !mLayerManager->GetRoot()) {
+    printf("??????\n");
     return;
   }
 
   TransformShadowTree();
 
   Layer* aLayer = mLayerManager->GetRoot();
   mozilla::layers::RenderTraceLayers(aLayer, "0000");
 
   mLayerManager->EndEmptyTransaction();
 
 #ifdef COMPOSITOR_PERFORMANCE_WARNING
   if (mExpectedComposeTime + TimeDuration::FromMilliseconds(15) < mozilla::TimeStamp::Now()) {
     printf_stderr("Compositor: Composite took %i ms.\n",
                   15 + (int)(mozilla::TimeStamp::Now() - mExpectedComposeTime).ToMilliseconds());
   }
 #endif
+
+  printf("End CompositorParent::Composite\n");
 }
 
 // Do a breadth-first search to find the first layer in the tree that is
 // scrollable.
 Layer*
 CompositorParent::GetPrimaryScrollableLayer()
 {
   Layer* root = mLayerManager->GetRoot();
diff --git a/gfx/layers/ipc/CompositorParent.h b/gfx/layers/ipc/CompositorParent.h
--- a/gfx/layers/ipc/CompositorParent.h
+++ b/gfx/layers/ipc/CompositorParent.h
@@ -23,17 +23,17 @@
 
 class nsIWidget;
 
 namespace mozilla {
 namespace layers {
 
 class LayerManager;
 
-// Represents (affine) transforms that are calculated from a content view.
+// Represents (affine) transforms thapt are calculated from a content view.
 struct ViewTransform {
   ViewTransform(nsIntPoint aTranslation = nsIntPoint(0, 0), float aXScale = 1, float aYScale = 1)
     : mTranslation(aTranslation)
     , mXScale(aXScale)
     , mYScale(aYScale)
   {}
 
   operator gfx3DMatrix() const
@@ -72,36 +72,38 @@ public:
   void SetTransformation(float aScale, nsIntPoint aScrollOffset);
   void AsyncRender();
 
   // Can be called from any thread
   void ScheduleRenderOnCompositorThread();
   void SchedulePauseOnCompositorThread();
   void ScheduleResumeOnCompositorThread(int width, int height);
 
+  virtual void ScheduleComposition();
+  
+  inline MessageLoop* CompositorLoop();
+  
 protected:
   virtual PLayersParent* AllocPLayers(const LayersBackend& aBackendType, int* aMaxTextureSize);
   virtual bool DeallocPLayers(PLayersParent* aLayers);
   virtual void ScheduleTask(CancelableTask*, int);
   virtual void Composite();
-  virtual void ScheduleComposition();
   virtual void SetFirstPaintViewport(const nsIntPoint& aOffset, float aZoom, const nsIntRect& aPageRect, const gfx::Rect& aCssPageRect);
   virtual void SetPageRect(float aZoom, const nsIntRect& aPageRect, const gfx::Rect& aCssPageRect);
   virtual void SyncViewportInfo(const nsIntRect& aDisplayPort, float aDisplayResolution, bool aLayersUpdated,
                                 nsIntPoint& aScrollOffset, float& aScaleX, float& aScaleY);
   void SetEGLSurfaceSize(int width, int height);
 
 private:
   void PauseComposition();
   void ResumeComposition();
   void ResumeCompositionAndResize(int width, int height);
 
   void TransformShadowTree();
 
-  inline MessageLoop* CompositorLoop();
   inline PlatformThreadId CompositorThreadID();
 
   // Platform specific functions
   /**
    * Does a breadth-first search to find the first layer in the tree with a
    * displayport set.
    */
   Layer* GetPrimaryScrollableLayer();
diff --git a/gfx/layers/ipc/ImageBridgeChild.cpp b/gfx/layers/ipc/ImageBridgeChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.cpp
@@ -0,0 +1,150 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageBridgeChild.h"
+#include "ImageContainerChild.h"
+#include "ImageBridgeParent.h"
+#include "gfxSharedImageSurface.h"
+#include "ImageLayers.h"
+#include "base/thread.h"
+#include "mozilla/ReentrantMonitor.h"
+
+namespace mozilla {
+namespace layers {
+
+static ImageBridgeChild* _hack_bridge = 0;
+
+ImageBridgeChild::ImageBridgeChild(base::Thread& aThread)
+{
+  mThread = &aThread;
+  if (!mThread->IsRunning()) {
+    mThread->Start();
+  }
+  _hack_bridge = this;
+}
+
+ImageBridgeChild::~ImageBridgeChild()
+{
+}
+
+
+// IPDL protocol
+
+
+PImageContainerChild* ImageBridgeChild::AllocPImageContainer(const PRUint64& handle)
+{
+  return new ImageContainerChild(this, handle);
+}
+
+bool ImageBridgeChild::DeallocPImageContainer(PImageContainerChild* aImgContainerChild)
+{
+  delete aImgContainerChild;
+  return true;
+}
+
+
+
+bool ImageBridgeChild::InImageBridgeChildThread() const {
+  return mThread->thread_id() == PlatformThread::CurrentId();
+}
+
+
+
+MessageLoop * ImageBridgeChild::GetMessageLoop() const
+{
+  return mThread->message_loop();
+}
+
+
+// async opertations:
+
+class ImageBridgeConnectionTask : public Task
+{
+public:
+  ImageBridgeConnectionTask(ImageBridgeChild * child, ImageBridgeParent * parent)
+  : mChild(child), mParent(parent) {}
+
+  void Run()
+  {
+    mChild->ConnectNow(mParent);
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageBridgeParent * mParent;
+};
+
+class ImageBridgeCreateContainerChildTask : public Task
+{
+public:
+  ImageBridgeCreateContainerChildTask(ImageBridgeChild * child, 
+                                      ImageContainerChild** result, 
+                                      ReentrantMonitor* barrier)
+  : mChild(child), mResult(result), mSync(barrier) {}
+
+  void Run()
+  {
+    ReentrantMonitorAutoEnter autoMon(*mSync);
+    *mResult = mChild->CreateImageContainerChildNow();
+    mSync->NotifyAll();
+  }
+private:
+  ImageBridgeChild * mChild;
+  ImageContainerChild** mResult;
+  ReentrantMonitor* mSync;
+};
+
+void ImageBridgeChild::ConnectNow(ImageBridgeParent* aParent)
+{
+    MessageLoop * parentMsgLoop = aParent->GetMessageLoop();
+    ipc::AsyncChannel * parentChannel = aParent->GetIPCChannel();
+    this->Open(parentChannel, parentMsgLoop, mozilla::ipc::AsyncChannel::Child);
+}
+
+void ImageBridgeChild::ConnectAsync(ImageBridgeParent* aParent)
+{
+  Task * t = new ImageBridgeConnectionTask(this, aParent);
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+}
+
+ImageContainerChild* ImageBridgeChild::CreateImageContainerChild()
+{
+  if (InImageBridgeChildThread()) {
+    return ImageBridgeChild::CreateImageContainerChildNow(); 
+  } 
+ 
+  // ImageContainerChild can only be alocated on the ImageBridgeChild thread, so se
+  // dispatch a task to the thread and block the current thread until the task has been
+  // executed.
+  ImageContainerChild* result = nsnull;
+  
+  ReentrantMonitor barrier("CreateImageContainerChild Lock");
+  ReentrantMonitorAutoEnter autoMon(barrier);
+
+  Task * t = new ImageBridgeCreateContainerChildTask(this, &result, &barrier);
+  
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+  
+  // should stop the thread until the ImageContainerChild has been created on 
+  // the other thread
+  barrier.Wait();
+  return result;
+}
+
+ImageContainerChild* ImageBridgeChild::CreateImageContainerChildNow()
+{
+  PRUint64 newID = 42; // TODO, generate a cross process unique id
+  ImageContainerChild* ctnChild = new ImageContainerChild(this,newID);
+  SendPImageContainerConstructor(ctnChild, newID);
+  return ctnChild;
+}
+
+ImageBridgeChild* ImageBridgeChild::_hack_GetBridge()
+{
+  return _hack_bridge;
+}
+
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeChild.h b/gfx/layers/ipc/ImageBridgeChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeChild.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGEBRIDGECHILD_H
+#define MOZILLA_GFX_IMAGEBRIDGECHILD_H
+
+#include "mozilla/layers/PImageBridgeChild.h"
+
+class gfxSharedImageSurface;
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class ImageContainerChild;
+class ImageBridgeParent;
+class ImageBridgeConnectionTask;
+class ImageBridgeCreateContainerChildTask;
+class MediaSharedImage;
+class Image;
+
+class ImageBridgeChild : public PImageBridgeChild
+{
+// NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VideoBridgeChild)
+friend class mozilla::layers::ImageBridgeConnectionTask;
+friend class mozilla::layers::ImageBridgeCreateContainerChildTask;
+
+public:
+
+  ImageBridgeChild(base::Thread& aThread);
+  ~ImageBridgeChild();
+
+  // IPDL protocol
+
+  // Temporary, not suitable for cross-process layers
+  // can be called from any thread
+  void ConnectAsync(ImageBridgeParent* aParent);
+    
+  /**
+   * Returns the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  base::Thread * GetThread() const
+  {
+    return mThread;
+  }
+
+  MessageLoop * GetMessageLoop() const;
+
+  /**
+   * Returns true if the current thread is the ImageBrdugeChild's thread.
+   *
+   * Can be called from any thread.
+   */
+  bool InImageBridgeChildThread() const;
+
+  ImageContainerChild* CreateImageContainerChild();
+
+  PImageContainerChild* AllocPImageContainer(const PRUint64&);
+  bool DeallocPImageContainer(PImageContainerChild* aImgContainerChild);
+
+  // TODO, temporary, will be removed soon
+  static ImageBridgeChild* _hack_GetBridge();
+
+protected:
+
+  /** 
+   * must be called in the ImageBridgeChild thread.
+   */
+  void ConnectNow(ImageBridgeParent* aParent);
+  ImageContainerChild* CreateImageContainerChildNow();
+
+  /**
+   * Dispatch a task in the ImageBridgeChild thread to send an 
+   * image through IPC to the compositor.
+   *
+   * Can be called from any thread.
+   */
+
+private:
+  base::Thread * mThread;
+};
+
+} // layers
+} // mozilla
+
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.cpp b/gfx/layers/ipc/ImageBridgeParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.cpp
@@ -0,0 +1,141 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/ImageBridgeParent.h"
+#include "mozilla/layers/ImageContainerParent.h"
+#include "mozilla/layers/CompositorParent.h"
+
+#include "base/thread.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace layers {
+
+/*
+bool ImageBridgeParent::RecvPushSharedImage(const LayerID& aLayerID, 
+                                            const MediaSharedImage& aImage)
+{
+  printf("ImageBridgeParent::RecvPushSharedImage (layerID: %i)\n", aLayerID);
+  
+  Layer * targetLayer = mCompositorParent->GetLayerManager()->GetLayerByID(aLayerID);
+  if (targetLayer) {
+
+      ShadowImageLayer * asShadowLayer = static_cast<ShadowImageLayer*>(targetLayer);
+
+      asShadowLayer->SetImageBridgeParent(this);
+      asShadowLayer->_hacked_Swap(aImage);
+      mCompositorParent->ScheduleComposition();
+
+  } else { printf("XXXXXX layer %i not found!\n", (int)aLayerID); }
+
+  SendReleasedSharedImage(aLayerID,aImage);
+  return true;
+}
+*/
+
+ImageBridgeParent::ImageBridgeParent(CompositorParent* aCompositor)
+: mCompositorParent(aCompositor)
+{
+
+}
+
+ImageBridgeParent::~ImageBridgeParent()
+{
+}
+
+
+PImageContainerParent* ImageBridgeParent::AllocPImageContainer(const PRUint64& aHandle)
+{
+  return new ImageContainerParent(this, aHandle);
+}
+
+bool ImageBridgeParent::DeallocPImageContainer(PImageContainerParent* toDealloc)
+{
+  delete toDealloc;
+  return true;
+}
+
+
+
+void ImageBridgeParent::ScheduleComposition()
+{
+  mCompositorParent->ScheduleComposition();
+}
+
+// IPDL protocol
+
+MessageLoop * ImageBridgeParent::GetMessageLoop() {
+  return mCompositorParent->CompositorLoop();
+}
+
+
+bool ImageBridgeParent::RecvWillStop()
+{
+  // TODO
+  return false;
+}
+
+namespace {
+
+  struct ImageIDPair {
+    ImageIDPair(SharedImage* aImage, PRUint64 aID)
+    : image(aImage), id(aID) {}
+    SharedImage*  image;
+    PRUint64      id;
+  };
+
+  nsTArray<ImageIDPair> sSharedImageMap;
+
+  enum {_INVALID_INDEX=-1};
+
+  int IndexOf(PRUint64 aID)
+  {
+    for (int i = 0; i < sSharedImageMap.Length(); ++i) {
+      if (sSharedImageMap[i].id == aID) {
+        return i;
+      }
+    }
+    return _INVALID_INDEX;
+  }
+
+
+}
+
+SharedImage* ImageBridgeParent::SwapSharedImage(PRUint64 aID, SharedImage* aImage)
+{
+  int idx = IndexOf(aID);
+  if (idx == _INVALID_INDEX) {
+    sSharedImageMap.AppendElement(ImageIDPair(aImage,aID));
+    return nsnull;
+  }
+  SharedImage* prev = sSharedImageMap[idx].image;
+  sSharedImageMap[idx].image = aImage;
+  return prev;
+}
+
+SharedImage* ImageBridgeParent::RemoveSharedImage(PRUint64 aID) 
+{
+  int idx = IndexOf(aID);
+  if (idx != _INVALID_INDEX) {
+    SharedImage* img = sSharedImageMap[idx].image;
+    sSharedImageMap.RemoveElementAt(idx);
+    return img;
+  }
+  return nsnull;
+}
+
+SharedImage* ImageBridgeParent::GetSharedImage(PRUint64 aID)
+{
+  int idx = IndexOf(aID);
+  if (idx != _INVALID_INDEX) {
+    return sSharedImageMap[idx].image;
+  }
+  return nsnull;
+}
+
+
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageBridgeParent.h b/gfx/layers/ipc/ImageBridgeParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageBridgeParent.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/PImageBridgeParent.h"
+#include "ShadowLayers.h"
+
+
+namespace base {
+class Thread;
+}
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeChild;
+class CompositorParent;
+class SharedImage;
+class Handle;
+class ImageHandle;
+
+SharedImage* GetSharedImageData(ImageHandle aHandle);
+
+class ImageBridgeParent : public PImageBridgeParent
+{
+// NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VideoBridgeChild)
+public:
+  typedef PRInt32 CompositorID_t;
+  // IPDL protocol
+
+  ImageBridgeParent(CompositorParent* aCompositor);
+  ~ImageBridgeParent();
+
+  void ScheduleComposition();
+
+  bool RecvWillStop();
+
+  // TODO replace PRUint 64 by a proper ImageHandle
+
+  PImageContainerParent* AllocPImageContainer(const PRUint64& aHandle);
+  bool DeallocPImageContainer(PImageContainerParent* toDealloc);
+
+  MessageLoop * GetMessageLoop();
+  
+
+  // temporarily duplicated function because we cant share 
+  // strcutures between protcols yet
+  static SharedImage* GetSharedImage(PRUint64 aID);
+  static SharedImage* SwapSharedImage(PRUint64 aID, SharedImage* aImage);
+  static SharedImage* RemoveSharedImage(PRUint64 aID);
+
+private:
+  // TODO: a list of ShadowImageLayers here
+  CompositorParent * mCompositorParent;
+};
+
+} // layers
+} // mozilla
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerChild.cpp b/gfx/layers/ipc/ImageContainerChild.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerChild.cpp
@@ -0,0 +1,160 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#include "ImageContainerChild.h"
+#include "gfxPlatform.h"
+#include "gfxSharedImageSurface.h"
+#include "ShadowLayers.h"
+
+namespace mozilla {
+namespace layers {
+
+// TODO debug
+static int _debug_sharedAllocCount = 0;
+static int _fake_layerID = 0;
+
+ImageContainerChild::~ImageContainerChild()
+{
+  printf("ImageContainerChild::~ImageContainerChild\n");
+}
+
+bool ImageContainerChild::RecvReleasedSharedImage(const MediaSharedImage& aImage)
+{
+  // TODO: pool them instead
+  DestroySharedImage(aImage);
+  return true;
+}
+
+
+bool ImageContainerChild::AllocBuffer(const gfxIntSize& aSize,
+                                   gfxASurface::gfxContentType aContent,
+                                   gfxSharedImageSurface** aBuffer)
+{
+  SharedMemory::SharedMemoryType shmemType = ipc::OptimalShmemType();
+  gfxASurface::gfxImageFormat format = gfxPlatform::GetPlatform()->OptimalFormatForContent(aContent);
+
+  nsRefPtr<gfxSharedImageSurface> back =
+    gfxSharedImageSurface::Create(this, aSize, format, shmemType);
+  if (!back)
+    return false;
+
+  *aBuffer = nsnull;
+  back.swap(*aBuffer);
+  return true;
+}
+
+void ImageContainerChild::DestroySharedImage(const MediaSharedImage& aImage)
+{
+  _debug_sharedAllocCount--;
+  printf("after deallocation: count is %i\n", _debug_sharedAllocCount);
+  
+  if (aImage.type() == MediaSharedImage::TMediaYUVImage) {
+    printf("\n\ndeallocate YUV shmems\n\n");
+    DeallocShmem(aImage.get_MediaYUVImage().Ydata());
+    DeallocShmem(aImage.get_MediaYUVImage().Udata());
+    DeallocShmem(aImage.get_MediaYUVImage().Vdata());
+  } else if (aImage.type() == MediaSharedImage::TMediaSurfaceDescriptor) {
+    printf("\ndeallocate SurfaceDescriptor shmem\n\n");
+    DeallocShmem(aImage.get_MediaSurfaceDescriptor().get_Shmem());
+  }
+
+}
+
+MediaSharedImage* ImageContainerChild::CopyImageIntoSharedImage(Image* image)
+{
+  printf("before allocation: count is %i\n", _debug_sharedAllocCount);
+  _debug_sharedAllocCount++;
+  /* how to access buffer directly into a SharedImage:
+    unsigned char * yBufferData = dest->get_MediSharedImage().Ydata().get<unsigned char>();
+    unsigned char * uBufferData = dest->get_MediSharedImage().Udata().get<unsigned char>();
+    unsigned char * vBufferData = dest->get_MediSharedImage().Vdata().get<unsigned char>();
+  */
+  // TODO: I don't test for BasicManager()->IsCompositingCheap() here,
+  // is this a problem?
+  if (image->GetFormat() == Image::PLANAR_YCBCR ) {
+    PlanarYCbCrImage *YCbCrImage = static_cast<PlanarYCbCrImage*>(image);
+    const PlanarYCbCrImage::Data *data = YCbCrImage->GetData();
+    NS_ASSERTION(data, "Must be able to retrieve yuv data from image!");
+    
+    // TODO: make sure the shmems dont gfet destroyed along with the temp surfaces
+    // ath the end of this scope
+    nsRefPtr<gfxSharedImageSurface> tempBufferY;
+    nsRefPtr<gfxSharedImageSurface> tempBufferU;
+    nsRefPtr<gfxSharedImageSurface> tempBufferV;
+    
+    if (!this->AllocBuffer(data->mYSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferY)) ||
+        !this->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferU)) ||
+        !this->AllocBuffer(data->mCbCrSize, gfxASurface::CONTENT_ALPHA,
+                           getter_AddRefs(tempBufferV))) {
+      NS_RUNTIMEABORT("creating SharedImage failed!");
+    }
+
+    for (int i = 0; i < data->mYSize.height; i++) {
+      memcpy(tempBufferY->Data() + i * tempBufferY->Stride(),
+             data->mYChannel + i * data->mYStride,
+             data->mYSize.width);
+    }
+    for (int i = 0; i < data->mCbCrSize.height; i++) {
+      memcpy(tempBufferU->Data() + i * tempBufferU->Stride(),
+             data->mCbChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+      memcpy(tempBufferV->Data() + i * tempBufferV->Stride(),
+             data->mCrChannel + i * data->mCbCrStride,
+             data->mCbCrSize.width);
+    }
+
+    return new MediaSharedImage( 
+              *(new MediaYUVImage(tempBufferY->GetShmem(),
+                                             tempBufferU->GetShmem(),
+                                             tempBufferV->GetShmem(),
+                                             data->GetPictureRect())));
+  } else {
+    NS_RUNTIMEABORT("Only YUVImage is supported here right now.");
+  }
+  return nsnull;
+}
+
+void ImageContainerChild::InitShadowLayerImageHandle(ShadowableLayer* layer)
+{
+  //SharedImage* img = new SharedImage( new SharedImageHandle(mID) );
+  //layer->getManager()->AsShadowForwarder()->PaintedImage(layer, img);
+}
+
+
+
+class ImageBridgeCopyAndSendTask : public Task
+{
+public:
+  ImageBridgeCopyAndSendTask(ImageContainerChild * child, 
+                             Image * aImage)
+  : mChild(child), mImage(aImage) {}
+
+  void Run()
+  {
+    _fake_layerID++;
+    printf("ImageBridgeCopyAndSendTask %i\n",_fake_layerID);
+    MediaSharedImage* img = 
+        mChild->CopyImageIntoSharedImage(mImage);
+    mChild->SendPushSharedImage(*img);
+  }
+private:
+  ImageContainerChild * mChild;
+  Image * mImage;
+};
+
+void ImageContainerChild::SendImageAsync(Image* aImage)
+{
+  printf("ImageContainerChild::SendImageAsync\n");
+  Task * t = new ImageBridgeCopyAndSendTask(this, aImage);
+  GetMessageLoop()->PostTask(FROM_HERE, t);
+}
+
+
+
+} // namespace
+} // namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerChild.h b/gfx/layers/ipc/ImageContainerChild.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerChild.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGECONTAINERCHILD_H
+#define MOZILLA_GFX_IMAGECONTAINERCHILD_H
+
+#include "mozilla/layers/PImageContainerChild.h"
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "ImageLayers.h"
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeCopyAndSendTask;
+
+class ImageContainerChild : public PImageContainerChild
+{
+  friend class ImageBridgeCopyAndSendTask;
+public:
+  ImageContainerChild(ImageBridgeChild* aBridge, PRUint64 aHandle)
+  : mBridge(aBridge), mHandle(aHandle) {}
+
+  virtual ~ImageContainerChild();
+
+  typedef MediaSharedImage SharedImage;
+  typedef MediaSurfaceDescriptor SurfaceDescriptor;
+  typedef MediaYUVImage YUVImage;
+
+  void SendImageAsync(Image* aImage);
+
+  MediaSharedImage * CopyImageIntoSharedImage(Image* aImage);
+
+  void InitShadowLayerImageHandle(ShadowableLayer* layer);
+
+  inline ImageBridgeChild* GetImageBridgeChild() const {
+    return mBridge; 
+  }
+
+  inline MessageLoop* GetMessageLoop() const {
+    return mBridge->GetMessageLoop();
+  }
+
+  inline bool InImageBridgeChildThread() const {
+    return mBridge->InImageBridgeChildThread();
+  }
+
+  const ImageHandle& GetHandle() const
+  {
+    return mHandle;
+  }
+
+  bool RecvReleasedSharedImage(const MediaSharedImage& aImage);
+
+protected:
+  /**
+   * Same as ShadowLayerForwarder::AllocBuffer.
+   *
+   * TODO: better doc :)
+   */
+  bool AllocBuffer(const gfxIntSize& aSize,
+                   gfxASurface::gfxContentType aContent,
+                   gfxSharedImageSurface** aBuffer);
+
+  bool AllocSharedImage(const gfxIntSize& aSize,
+                        gfxASurface::gfxContentType aContent,
+                        MediaSharedImage& aImage);
+
+  void DestroySharedImage(const MediaSharedImage& aSurface);
+
+private:
+
+  ImageBridgeChild* mBridge;
+  ImageHandle mHandle;
+  // shared image pool here 
+};
+
+
+} // namespace
+} // namespace
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerParent.cpp b/gfx/layers/ipc/ImageContainerParent.cpp
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerParent.cpp
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/layers/ImageContainerParent.h"
+#include "mozilla/layers/ImageBridgeParent.h"
+#include "CompositorParent.h"
+
+
+namespace mozilla {
+namespace layers {
+
+namespace {
+
+  SharedImage* ToSharedImage(const MediaSharedImage& img)
+  {
+    if (img.type() == MediaSharedImage::TMediaYUVImage) {
+      return new SharedImage(img.get_MediaYUVImage().Ydata(),
+                             img.get_MediaYUVImage().Udata(),
+                             img.get_MediaYUVImage().Vdata());
+    } else {
+      NS_ABORT_IF_FALSE(false,"TODO: missing types in convertion from MediaSharedImage to SharedImage");
+      return nsnull;
+    }
+  }
+
+  MediaSharedImage* ToMediaSharedImage(const SharedImage& img)
+  {
+    if (img.type() == SharedImage::TYUVImage) {
+      return new MediaSharedImage(img.get_YUVImage().Ydata(),
+                             img.get_YUVImage().Udata(),
+                             img.get_YUVImage().Vdata());
+    } else {
+      NS_ABORT_IF_FALSE(false,"TODO: missing types in convertion from MediaSharedImage to SharedImage");
+      return nsnull;
+    }
+  }
+} // anonymous namespace
+
+bool ImageContainerParent::RecvPushSharedImage(const MediaSharedImage& aImage)
+{
+  printf(" -- ImageContainerParent::RecvPushSharedImage");
+
+  // TODO
+  SharedImage * prevImage = ImageBridgeParent::SwapSharedImage(mHandle.id, ToSharedImage(aImage));
+
+  mBridge->ScheduleComposition();
+  if (prevImage) {
+    SendReleasedSharedImage(*ToMediaSharedImage(*prevImage));
+  }
+  return true;
+}
+
+
+} // namespace
+} // namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/ImageContainerParent.h b/gfx/layers/ipc/ImageContainerParent.h
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/ImageContainerParent.h
@@ -0,0 +1,34 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZILLA_GFX_IMAGECONTAINERPARENT_H
+#define MOZILLA_GFX_IMAGECONTAINERPARENT_H
+
+#include "mozilla/layers/PImageContainerParent.h"
+
+namespace mozilla {
+namespace layers {
+
+class ImageBridgeParent;
+
+class ImageContainerParent : public PImageContainerParent
+{
+public:
+
+  ImageContainerParent(ImageBridgeParent* aBridge, PRUint64 aHandle)
+  : mBridge(aBridge), mHandle(aHandle) {}
+
+  bool RecvPushSharedImage(const MediaSharedImage& aImage);
+
+private:
+  ImageBridgeParent* mBridge;
+  ImageHandle mHandle;
+};
+
+
+} // namespace
+} // namespace
+
+#endif
\ No newline at end of file
diff --git a/gfx/layers/ipc/PImageBridge.ipdl b/gfx/layers/ipc/PImageBridge.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PImageBridge.ipdl
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PImageContainer;
+
+using ImageHandle;
+
+namespace mozilla {
+namespace layers {
+
+/**
+ * The PImageBridge protocol is used to allow isolated threads or processes to push
+ * frames directly to the compositor thread/process without relying on the main thread
+ * which might be too busy dealing with content script.
+ */
+async protocol PImageBridge
+{
+  manages PImageContainer;
+
+parent:
+  WillStop();
+  
+  // TODO replace PRUint 64 by a proper ImageHandle
+  PImageContainer(PRUint64 handle_id);
+};
+
+
+} //namespace
+} //namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/PImageContainer.ipdl b/gfx/layers/ipc/PImageContainer.ipdl
new file mode 100644
--- /dev/null
+++ b/gfx/layers/ipc/PImageContainer.ipdl
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PImageBridge;
+
+include "gfxipc/ShadowLayerUtils.h";
+
+using nsIntPoint;
+using nsIntRect;
+using nsIntRegion;
+using nsIntSize;
+using mozilla::layers::SurfaceDescriptorX11;
+using mozilla::null_t;
+using mozilla::WindowsHandle;
+
+namespace mozilla {
+namespace layers {
+
+struct ImageHandle {
+  PRUint64 id;
+};
+
+struct MediaSurfaceDescriptorD3D10 {
+  WindowsHandle handle;
+};
+
+union MediaSurfaceDescriptor {
+  Shmem;
+  MediaSurfaceDescriptorD3D10;
+  SurfaceDescriptorX11;
+};
+
+struct MediaYUVImage {
+  Shmem Ydata;
+  Shmem Udata;
+  Shmem Vdata;
+  nsIntRect picture;
+};
+
+union MediaSharedImage {
+  MediaSurfaceDescriptor;
+  MediaYUVImage;
+  null_t;
+};
+
+
+/**
+ * The PImageBridge protocol is used to allow isolated threads or processes to push
+ * frames directly to the compositor thread/process without relying on the main thread
+ * which might be too busy dealing with content script.
+ */
+async protocol PImageContainer
+{
+  manager PImageBridge;
+
+child:
+  // Give back the child thread/process ownership to a SharedImage
+  ReleasedSharedImage(MediaSharedImage image);
+
+parent:
+
+  // Send a SharedImage to the compositor giving to the compositor ownership 
+  // of the image.
+  PushSharedImage(MediaSharedImage image);
+  __delete__();
+
+};
+
+
+} //namespace
+} //namespace
\ No newline at end of file
diff --git a/gfx/layers/ipc/PLayers.ipdl b/gfx/layers/ipc/PLayers.ipdl
--- a/gfx/layers/ipc/PLayers.ipdl
+++ b/gfx/layers/ipc/PLayers.ipdl
@@ -40,32 +40,37 @@ struct OpCreateContainerLayer  { PLayer 
 struct OpCreateImageLayer      { PLayer layer; };
 struct OpCreateColorLayer      { PLayer layer; };
 struct OpCreateCanvasLayer     { PLayer layer; };
 
 struct SurfaceDescriptorD3D10 {
   WindowsHandle handle;
 };
 
+struct SharedImageHandle {
+  PRUint64 id;
+};
+
 union SurfaceDescriptor {
   Shmem;
   SurfaceDescriptorD3D10;
   SurfaceDescriptorX11;
 };
 
 struct YUVImage {
   Shmem Ydata;
   Shmem Udata;
   Shmem Vdata;
   nsIntRect picture;
 };
 
 union SharedImage {
   SurfaceDescriptor;
   YUVImage;
+  SharedImageHandle;
   null_t;
 };
 
 struct ThebesBuffer {
   SurfaceDescriptor buffer;
   nsIntRect rect;
   nsIntPoint rotation; 
 };
diff --git a/gfx/layers/ipc/ShadowLayers.cpp b/gfx/layers/ipc/ShadowLayers.cpp
--- a/gfx/layers/ipc/ShadowLayers.cpp
+++ b/gfx/layers/ipc/ShadowLayers.cpp
@@ -105,16 +105,17 @@ struct AutoTxnEnd {
   Transaction* mTxn;
 };
 
 ShadowLayerForwarder::ShadowLayerForwarder()
  : mShadowManager(NULL)
  , mMaxTextureSize(0)
  , mParentBackend(LayerManager::LAYERS_NONE)
  , mIsFirstPaint(false)
+ , mImageBridgeChild(NULL)
 {
   mTxn = new Transaction();
 }
 
 ShadowLayerForwarder::~ShadowLayerForwarder()
 {
   NS_ABORT_IF_FALSE(mTxn->Finished(), "unfinished transaction?");
   delete mTxn;
diff --git a/gfx/layers/ipc/ShadowLayers.h b/gfx/layers/ipc/ShadowLayers.h
--- a/gfx/layers/ipc/ShadowLayers.h
+++ b/gfx/layers/ipc/ShadowLayers.h
@@ -32,16 +32,18 @@ class ShadowColorLayer;
 class ShadowCanvasLayer;
 class SurfaceDescriptor;
 class ThebesBuffer;
 class TiledLayerComposer;
 class Transaction;
 class SharedImage;
 class CanvasSurface;
 class BasicTiledLayerBuffer;
+class ImageBridgeParent;
+class ImageBridgeChild;
 
 /**
  * We want to share layer trees across thread contexts and address
  * spaces for several reasons; chief among them
  *
  *  - a parent process can paint a child process's layer tree while
  *    the child process is blocked, say on content script.  This is
  *    important on mobile devices where UI responsiveness is key.
@@ -300,16 +302,19 @@ public:
   /**
    * Flag the next paint as the first for a document.
    */
   void SetIsFirstPaint() { mIsFirstPaint = true; }
 
   virtual PRInt32 GetMaxTextureSize() const { return mMaxTextureSize; }
   void SetMaxTextureSize(PRInt32 aMaxTextureSize) { mMaxTextureSize = aMaxTextureSize; }
 
+  void SetImageBridge(ImageBridgeChild* aBridge) { mImageBridgeChild = aBridge; }
+  ImageBridgeChild* GetImageBridge() const { return mImageBridgeChild; }
+
 protected:
   ShadowLayerForwarder();
 
   PLayersChild* mShadowManager;
 
 private:
   bool PlatformAllocDoubleBuffer(const gfxIntSize& aSize,
                                    gfxASurface::gfxContentType aContent,
@@ -327,16 +332,17 @@ private:
 
   static void PlatformSyncBeforeUpdate();
 
   Transaction* mTxn;
   PRInt32 mMaxTextureSize;
   LayersBackend mParentBackend;
 
   bool mIsFirstPaint;
+  ImageBridgeChild * mImageBridgeChild;
 };
 
 
 class ShadowLayerManager : public LayerManager
 {
 public:
   virtual ~ShadowLayerManager() {}
 
diff --git a/gfx/layers/ipc/ipdl.mk b/gfx/layers/ipc/ipdl.mk
--- a/gfx/layers/ipc/ipdl.mk
+++ b/gfx/layers/ipc/ipdl.mk
@@ -1,9 +1,11 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 IPDLSRCS = \
   PCompositor.ipdl \
   PLayer.ipdl \
   PLayers.ipdl \
+  PImageBridge.ipdl \
+  PImageContainer.ipdl \
   $(NULL)
diff --git a/gfx/layers/opengl/ImageLayerOGL.cpp b/gfx/layers/opengl/ImageLayerOGL.cpp
--- a/gfx/layers/opengl/ImageLayerOGL.cpp
+++ b/gfx/layers/opengl/ImageLayerOGL.cpp
@@ -1,15 +1,15 @@
 /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "gfxSharedImageSurface.h"
-
+#include "mozilla/layers/ImageContainerParent.h"
 #include "ImageLayerOGL.h"
 #include "gfxImageSurface.h"
 #include "gfxUtils.h"
 #include "yuv_convert.h"
 #include "GLContextProvider.h"
 #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 # include "GLXLibrary.h"
 # include "mozilla/X11Util.h"
@@ -644,16 +644,50 @@ ShadowImageLayerOGL::ShadowImageLayerOGL
   : ShadowImageLayer(aManager, nsnull)
   , LayerOGL(aManager)
 {
   mImplData = static_cast<LayerOGL*>(this);
 }
 
 ShadowImageLayerOGL::~ShadowImageLayerOGL()
 {}
+/*
+bool
+ShadowImageLayerOGL::_hack_Init(const MediaSharedImage& aFront)
+{
+  MediaYUVImage yuv = aFront.get_MediaYUVImage();
+
+  nsRefPtr<gfxSharedImageSurface> surfY =
+    gfxSharedImageSurface::Open(yuv.Ydata());
+  nsRefPtr<gfxSharedImageSurface> surfU =
+    gfxSharedImageSurface::Open(yuv.Udata());
+  nsRefPtr<gfxSharedImageSurface> surfV =
+    gfxSharedImageSurface::Open(yuv.Vdata());
+
+  mSize = surfY->GetSize();
+  mCbCrSize = surfU->GetSize();
+
+  if (!mYUVTexture[0].IsAllocated()) {
+    mYUVTexture[0].Allocate(gl());
+    mYUVTexture[1].Allocate(gl());
+    mYUVTexture[2].Allocate(gl());
+  }
+
+  NS_ASSERTION(mYUVTexture[0].IsAllocated() &&
+               mYUVTexture[1].IsAllocated() &&
+               mYUVTexture[2].IsAllocated(),
+               "Texture allocation failed!");
+
+  gl()->MakeCurrent();
+  SetClamping(gl(), mYUVTexture[0].GetTextureID());
+  SetClamping(gl(), mYUVTexture[1].GetTextureID());
+  SetClamping(gl(), mYUVTexture[2].GetTextureID());
+  return true;
+}
+*/
 
 bool
 ShadowImageLayerOGL::Init(const SharedImage& aFront)
 {
   if (aFront.type() == SharedImage::TSurfaceDescriptor) {
     SurfaceDescriptor desc = aFront.get_SurfaceDescriptor();
     nsRefPtr<gfxASurface> surf =
       ShadowLayerForwarder::OpenDescriptor(desc);
@@ -693,20 +727,58 @@ ShadowImageLayerOGL::Init(const SharedIm
     SetClamping(gl(), mYUVTexture[0].GetTextureID());
     SetClamping(gl(), mYUVTexture[1].GetTextureID());
     SetClamping(gl(), mYUVTexture[2].GetTextureID());
     return true;
   }
   return false;
 }
 
+/*
+void ShadowImageLayerOGL::_hacked_Swap(const MediaSharedImage& aNewFront)
+{
+  if (!mDestroyed) {
+    const MediaYUVImage& yuv = aNewFront.get_MediaYUVImage();
+
+    nsRefPtr<gfxSharedImageSurface> surfY =
+      gfxSharedImageSurface::Open(yuv.Ydata());
+    nsRefPtr<gfxSharedImageSurface> surfU =
+      gfxSharedImageSurface::Open(yuv.Udata());
+    nsRefPtr<gfxSharedImageSurface> surfV =
+      gfxSharedImageSurface::Open(yuv.Vdata());
+    mPictureRect = yuv.picture();
+
+    gfxIntSize size = surfY->GetSize();
+    gfxIntSize CbCrSize = surfU->GetSize();
+    if (size != mSize || mCbCrSize != CbCrSize || !mYUVTexture[0].IsAllocated()) {
+      _hack_Init(aNewFront);
+    }
+
+    PlanarYCbCrImage::Data data;
+    data.mYChannel = surfY->Data();
+    data.mYStride = surfY->Stride();
+    data.mYSize = surfY->GetSize();
+    data.mCbChannel = surfU->Data();
+    data.mCrChannel = surfV->Data();
+    data.mCbCrStride = surfU->Stride();
+    data.mCbCrSize = surfU->GetSize();
+
+    UploadYUVToTexture(gl(), data, &mYUVTexture[0], &mYUVTexture[1], &mYUVTexture[2]);
+  }
+}
+*/
+
 void
 ShadowImageLayerOGL::Swap(const SharedImage& aNewFront,
                           SharedImage* aNewBack)
 {
+  //if (GetImageBridgeParent()) {
+    printf("---- WTF! ShadowImageLayerOGL::Swap called while using image bridge\n");
+    return;
+  //} 
   if (!mDestroyed) {
     if (aNewFront.type() == SharedImage::TSurfaceDescriptor) {
       nsRefPtr<gfxASurface> surf =
         ShadowLayerForwarder::OpenDescriptor(aNewFront.get_SurfaceDescriptor());
       gfxIntSize size = surf->GetSize();
       if (mSize != size || !mTexImage ||
           mTexImage->GetContentType() != surf->GetContentType()) {
         Init(aNewFront);
diff --git a/gfx/layers/opengl/LayerManagerOGL.cpp b/gfx/layers/opengl/LayerManagerOGL.cpp
--- a/gfx/layers/opengl/LayerManagerOGL.cpp
+++ b/gfx/layers/opengl/LayerManagerOGL.cpp
@@ -704,16 +704,17 @@ LayerManagerOGL::BindAndDrawQuadWithText
     }
     mGLContext->fDisableVertexAttribArray(texCoordAttribIndex);
   }
 }
 
 void
 LayerManagerOGL::Render()
 {
+  printf("LayerManagerOGL::Render\n");
   SAMPLE_LABEL("LayerManagerOGL", "Render");
   if (mDestroyed) {
     NS_WARNING("Call on destroyed layer manager");
     return;
   }
 
   nsIntRect rect;
   if (mIsRenderingToEGLSurface) {
diff --git a/layout/generic/nsVideoFrame.cpp b/layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp
+++ b/layout/generic/nsVideoFrame.cpp
@@ -22,16 +22,17 @@
 #include "nsTransform2D.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsImageFrame.h"
 #include "nsIImageLoadingContent.h"
 #include "nsCSSRendering.h"
 #include "nsContentUtils.h"
+#include "mozilla/layers/ShadowLayers.h"
 
 #ifdef ACCESSIBILITY
 #include "nsAccessibilityService.h"
 #endif
 
 using namespace mozilla;
 using namespace mozilla::layers;
 using namespace mozilla::dom;
@@ -192,18 +193,17 @@ nsVideoFrame::BuildLayer(nsDisplayListBu
 
   nsRefPtr<ImageLayer> layer = static_cast<ImageLayer*>
     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
   if (!layer) {
     layer = aManager->CreateImageLayer();
     if (!layer)
       return nsnull;
   }
-
-  layer->SetContainer(container);
+  
   layer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(this));
   layer->SetContentFlags(Layer::CONTENT_OPAQUE);
   // Set a transform on the layer to draw the video in the right place
   gfxMatrix transform;
   transform.Translate(r.TopLeft());
   transform.Scale(r.Width()/frameSize.width, r.Height()/frameSize.height);
   layer->SetTransform(gfx3DMatrix::From2D(transform));
   layer->SetVisibleRegion(nsIntRect(0, 0, frameSize.width, frameSize.height));
diff --git a/widget/xpwidgets/nsBaseWidget.cpp b/widget/xpwidgets/nsBaseWidget.cpp
--- a/widget/xpwidgets/nsBaseWidget.cpp
+++ b/widget/xpwidgets/nsBaseWidget.cpp
@@ -1,15 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Util.h"
 
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "mozilla/layers/ImageBridgeParent.h"
 #include "mozilla/layers/CompositorChild.h"
 #include "mozilla/layers/CompositorParent.h"
 #include "nsBaseWidget.h"
 #include "nsDeviceContext.h"
 #include "nsCOMPtr.h"
 #include "nsGfxCIID.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
@@ -899,16 +901,21 @@ void nsBaseWidget::CreateCompositor()
       lf->SetShadowManager(shadowManager);
       if (mUseAcceleratedRendering)
         lf->SetParentBackendType(LayerManager::LAYERS_OPENGL);
       else
         lf->SetParentBackendType(LayerManager::LAYERS_BASIC);
       lf->SetMaxTextureSize(maxTextureSize);
 
       mLayerManager = lm;
+
+      mImageBridgeChild = new mozilla::layers::ImageBridgeChild(*new base::Thread("ImageBridgeChild"));
+      mImageBridgeParent = new mozilla::layers::ImageBridgeParent(mCompositorParent);
+      mImageBridgeChild->ConnectAsync(mImageBridgeParent);
+      lf->SetImageBridge(mImageBridgeChild);
     } else {
       // We don't currently want to support not having a LayersChild
       NS_RUNTIMEABORT("failed to construct LayersChild");
       delete lm;
       mCompositorChild = nsnull;
     }
   }
 }
diff --git a/widget/xpwidgets/nsBaseWidget.h b/widget/xpwidgets/nsBaseWidget.h
--- a/widget/xpwidgets/nsBaseWidget.h
+++ b/widget/xpwidgets/nsBaseWidget.h
@@ -18,16 +18,18 @@
 class nsIContent;
 class nsAutoRollup;
 class gfxContext;
 
 namespace mozilla {
 namespace layers {
 class CompositorChild;
 class CompositorParent;
+class ImageBridgeChild;
+class ImageBridgeParent;
 }
 }
 
 namespace base {
 class Thread;
 }
 
 /**
@@ -283,16 +285,18 @@ protected:
   ViewWrapper*      mViewWrapperPtr;
   EVENT_CALLBACK    mEventCallback;
   EVENT_CALLBACK    mViewCallback;
   nsDeviceContext* mContext;
   nsRefPtr<LayerManager> mLayerManager;
   nsRefPtr<LayerManager> mBasicLayerManager;
   nsRefPtr<CompositorChild> mCompositorChild;
   nsRefPtr<CompositorParent> mCompositorParent;
+  mozilla::layers::ImageBridgeChild* mImageBridgeChild;
+  mozilla::layers::ImageBridgeParent* mImageBridgeParent;
   Thread*           mCompositorThread;
   nscolor           mBackground;
   nscolor           mForeground;
   nsCursor          mCursor;
   nsWindowType      mWindowType;
   nsBorderStyle     mBorderStyle;
   bool              mOnDestroyCalled;
   bool              mUseAcceleratedRendering;
